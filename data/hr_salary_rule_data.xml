<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

<!-- ============================================= -->
<!-- REGLA: SALARIO BÁSICO (SALARIO) - CORREGIDA -->
<!-- ============================================= -->
<record id="hr_rule_salario_basico" model="hr.salary.rule">
    <field name="name">Salario Básico</field>
    <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
    <field name="sequence">10</field>
    <field name="code">SALARIO</field>
    <field name="category_id" ref="hr_payroll.BASIC"/>
    <field name="condition_select">python</field>
    <field name="condition_python">
        <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - CORREGIDO)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is

# --- Employee Type Determination (CORREGIDO para Aprendices) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': 
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': 
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Common helper variables (CORREGIDO SIN hasattr) ---
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    # Acceso directo a los atributos. Si alguno no existe, saltará al except AttributeError.
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding = payslip.currency_id.rounding
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : 
            currency_rounding = test_float
            precision_rounding = test_float
except (AttributeError, ValueError, TypeError):
    # Si hay AttributeError (campo no existe) o error de conversión,
    # se mantienen los defaults para currency_rounding y precision_rounding.
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALARIO condition ---
result = False
if is_regular and contract: 
    contract_wage_value = 0.0
    try:
        contract_wage_value = float(contract.wage or 0.0) # Añadido 'or 0.0' por si wage es None
    except (ValueError, TypeError, AttributeError):
        contract_wage_value = 0.0
    
    if contract_wage_value > precision_rounding: 
        result = True
        ]]>
    </field>
    <field name="amount_select">code</field>
    <field name="amount_python_compute">
        <![CDATA[
# --- Preamble (CORREGIDO SIN hasattr) ---
currency_rounding = 0.01
precision_rounding = 0.01
try:
    # Acceso directo a los atributos.
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None: # Asumimos que los campos existen
        current_payslip_currency_rounding = payslip.currency_id.rounding
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 :
            currency_rounding = test_float
            precision_rounding = test_float
except (AttributeError, ValueError, TypeError):
    # Si hay AttributeError (campo no existe) o error de conversión, se mantienen los defaults.
    pass 
# ======================================================

result = 0.0
result_qty = 0.0

days_in_month_theory = 30.0 
days_absent_not_paid_as_salary = 0.0

leave_codes_reducing_salary_payment = [
    'LNR', 'SUS', 
    'IGE1_2', 'IGE3_90', 'IGE91_180', 'IGE181_MAS', 
    'LMA', 'LR', 'ATEP', 'VACDISF'
]

# 'worked_days' es un BrowsableObject. El acceso a sus elementos es como un diccionario
# (ej. worked_days.get('LNR')) o iterando si es una lista de objetos.
# Vamos a asumir que podemos usar .get(code) o iterar y acceder a .code
if worked_days: 
    for code_to_check in leave_codes_reducing_salary_payment:
        wd_line_obj = None # Inicializar
        try:
            # Intenta acceder como si fuera un diccionario de objetos BrowsableObject
            # (como lo hace Odoo a menudo con worked_days pasados a reglas)
            wd_line_obj = worked_days.get(code_to_check) 
            
            if wd_line_obj: # Si la clave existe y devuelve un objeto
                # Acceso directo a number_of_days, asumiendo que existe si wd_line_obj es válido
                num_days = wd_line_obj.number_of_days 
                
                # Verificar tipo sin isinstance si es necesario, o asumir que es numérico o None
                # Si isinstance no está permitido, esta es la parte más riesgosa.
                # Una forma simple es intentar la conversión y capturar el error.
                try:
                    days_absent_not_paid_as_salary += float(num_days or 0.0)
                except (ValueError, TypeError): # Si no es convertible a float
                    pass # No sumar si no se puede convertir
                    
        except (AttributeError, KeyError): # AttributeError si .get no existe o .number_of_days no existe
                                          # KeyError si .get no es soportado y es un dict estricto
            # Si el código no existe como un atributo directo o clave, o el objeto no tiene number_of_days
            pass

days_to_pay_salary = max(0.0, days_in_month_theory - days_absent_not_paid_as_salary)

contract_wage_value = 0.0
if contract: 
    try:
        # Acceso directo a contract.wage
        contract_wage_value = float(contract.wage or 0.0) 
    except (AttributeError, ValueError, TypeError):
        contract_wage_value = 0.0

if days_to_pay_salary > precision_rounding and contract_wage_value > precision_rounding:
    daily_rate = contract_wage_value / days_in_month_theory
    
    result = daily_rate
    result_qty = days_to_pay_salary
    
    if not (abs(result) < precision_rounding): 
        num_decimals = 2 
        if currency_rounding == 0.01: num_decimals = 2
        elif currency_rounding == 1.0: num_decimals = 0
        elif currency_rounding == 10.0: num_decimals = -1 
        elif currency_rounding == 100.0: num_decimals = -2
        
        if num_decimals >= 0:
            factor = 10 ** num_decimals
            result = float(int(result * factor + (0.5 if result >=0 else -0.5))) / factor
        else: 
            factor = 10 ** abs(num_decimals)
            result = float(int(result / factor + (0.5 if result >=0 else -0.5))) * factor
    else:
        result = 0.0
else:
    result = 0.0
    result_qty = 0.0
        ]]>
    </field>
    <!-- === Campos Específicos Nómina Electrónica Colombia === -->
    <field name="type_concept">earn</field>
    <field name="earn_category">basic</field>
    <field name="edi_is_detailed" eval="True"/>
    <field name="edi_quantity_select">worked_days</field>
    <field name="edi_quantity_worked_days_code">ATT</field>
    <field name="edi_percent_select">default</field>
    <field name="co_partner_select">code</field>
    <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
    </field>
    </record>

<!-- ============================================= -->
<!--     REGLA: SALARIO INTEGRAL   -->
<!-- ============================================= -->
<record id="hr_rule_salario_integral" model="hr.salary.rule">
    <field name="name">Salario Integral</field>
    <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
    <field name="sequence">11</field> <field name="code">SALARIO_INTEGRAL</field>
    <field name="category_id" ref="hr_payroll.BASIC"/>
    <field name="condition_select">python</field>
    <field name="condition_python">
        <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (CORREGIDO)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is

# --- Employee Type Determination (CORREGIDO para Aprendices) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False  # Específico para tipo de aprendiz
is_apprentice_productiva = False # Específico para tipo de aprendiz
is_any_apprentice = False      # General si es cualquier tipo de aprendiz

if contract:
    # Determina si es integral (acceso directo)
    try:
        if contract.integral_salary: # Si el campo es True
            is_integral = True
    except AttributeError:
        pass # Si el campo no existe, is_integral permanece False

    # Determina si es aprendiz (usando type_worker_id.code DIAN '12' o '19')
    try:
        if contract.type_worker_id and contract.type_worker_id.code:
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass # Si los campos no existen, las variables de aprendiz permanecen False
            
    # Determina si es regular
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
# (La lógica completa de ajuste de precisión del preámbulo original puede ir aquí si es necesaria
# para otras comprobaciones, más allá de > 0)
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALARIO_INTEGRAL condition ---
result = False
if is_integral:  # La regla se aplica si el contrato está marcado como integral
    contract_wage_value = 0.0
    try:
        # Asumimos que contract.wage contiene el valor total del salario integral mensual
        contract_wage_value = float(contract.wage)
    except (ValueError, TypeError, AttributeError):
        # Si contract.wage no existe, no es un número, o es None, se considera 0.0
        contract_wage_value = 0.0
    
    # La regla se aplica si es integral Y el monto del salario integral es mayor que cero.
    if contract_wage_value > precision_rounding: 
        result = True
        ]]>
    </field>
    <field name="amount_select">code</field>
    <field name="amount_python_compute">
        <![CDATA[
# --- Environment objects ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env
result = 0.0
result_qty = 1.0 # Para salario integral, la cantidad es 1 (el monto total del mes)

if contract and isinstance(contract.wage, (int, float)):
    result = contract.wage

# Para salario integral, usualmente no se prorratea por ausencias cortas como IGE
# de la misma forma que el salario regular. El 'result' es el salario mensual completo.
# Si se requiere un prorrateo para ausencias muy largas, la lógica debería ir aquí.
# Por ahora, se asume el pago completo del contract.wage mensual.
        ]]>
    </field>
    <field name="type_concept">earn</field>
    <field name="earn_category">basic</field> <field name="edi_is_detailed" eval="False"/>
    <field name="edi_quantity_select">default</field>
    <field name="edi_percent_select">default</field>
    <field name="co_partner_select">default</field>
</record>


<!-- ============================================= -->
<!--     REGLA: AUXILIO DE TRANSPORTE (AUXTRANS) - CORREGIDA   -->
<!-- ============================================= -->
<record id="hr_rule_auxilio_transporte" model="hr.salary.rule">
    <field name="name">Auxilio de Transporte</field>
    <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
    <field name="sequence">20</field>
    <field name="code">AUXTRANS</field>
    <field name="category_id" ref="hr_payroll.BASIC"/>
    <field name="condition_select">python</field>
    <field name="condition_python">
        <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - CORREGIDO)
# ======================================================
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': 
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': 
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

smmlv = 0.0
precision_rounding = 0.01 # Usado para comparaciones > 0
# No necesitamos currency_rounding en la condición, solo smmlv y precision_rounding.

company_obj_cond = None # Evitar conflicto de nombre con amount_python_compute
if contract and contract.company_id: # Asegurar que contract y company_id existen
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        # Acceso directo, si 'smmlv_value' no existe, dará AttributeError
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None: # Verificar que no sea None antes de float()
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv 
             # else: smmlv permanece 0.0
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0 # Si hay error, smmlv es 0.0
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for AUXTRANS condition ---
result = False
if is_regular and contract and smmlv > 0: 
    contract_wage_value = 0.0
    try:
        # Acceso directo a contract.wage.
        contract_wage_value = float(contract.wage or 0.0) # or 0.0 por si wage es None
    except (AttributeError, ValueError, TypeError):
        contract_wage_value = 0.0

    # El auxilio de transporte aplica si el salario es menor a 2 SMMLV.
    # La comparación contract_wage_value < (2.0 * smmlv) es clave.
    # Se usa (2.0 * smmlv - precision_rounding) para evitar problemas de flotantes si wage es casi 2 SMMLV.
    if contract_wage_value > precision_rounding and contract_wage_value < (2.0 * smmlv - precision_rounding):
        result = True
        ]]>
    </field>
    <field name="amount_select">code</field>
    <field name="amount_python_compute">
        <![CDATA[
# --- Preamble (re-define essentials for this scope) ---
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding = payslip.currency_id.rounding
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 :
            currency_rounding = test_float
            precision_rounding = test_float
except (AttributeError, ValueError, TypeError):
    pass 
# ======================================================

result = 0.0
result_qty = 0.0 

days_in_month_theory = 30.0
days_absent_affecting_aux = 0.0
monthly_transport_subsidy = 0.0
FALLBACK_TRANSPORT_ALLOWANCE = 162000.0 # VALOR AUXILIO TRANSPORTE 2024 - ¡AJUSTAR SI ES NECESARIO!

company_obj_amount = None # Evitar conflicto
if contract and contract.company_id:
    company_obj_amount = contract.company_id

if company_obj_amount:
    raw_stm_value = None
    try:
        # Acceso directo. Si 'stm_value' no existe, AttributeError.
        raw_stm_value = company_obj_amount.stm_value 
    except AttributeError: 
        pass 

    temp_stm_value = 0.0
    if raw_stm_value is not None:
        try:
            temp_stm_value = float(raw_stm_value)
        except (ValueError, TypeError):
            pass 
    
    if temp_stm_value > precision_rounding:
        monthly_transport_subsidy = temp_stm_value
    else:
        # Si stm_value no es válido o cero, usar el fallback (que debería ser el legal vigente)
        monthly_transport_subsidy = FALLBACK_TRANSPORT_ALLOWANCE 
else: # Si no hay company_obj_amount
    monthly_transport_subsidy = FALLBACK_TRANSPORT_ALLOWANCE

# !!! ================================================================================= !!!
# !!! CRÍTICO: Lista de CÓDIGOS de hr.work.entry.type que descuentan Aux. Transporte.   !!!
# !!! Esta lista debe incluir TODAS las ausencias (incapacidades, licencias,          !!!
# !!! vacaciones, LNR, SUS, etc.) que afecten el pago del auxilio.                    !!!
# !!! ================================================================================= !!!
leave_codes_reducing_aux_payment = [
    'LNR', 'SUS', 
    'IGE1_2', 'IGE3_90', 'IGE91_180', 'IGE181_MAS', # O tus códigos específicos para IGE
    'LMA', 
    'LR', 
    'ATEP', 
    'VACDISF' 
]

# 'worked_days' es un BrowsableObject que se comporta como un diccionario
if worked_days: 
    for code_leave in leave_codes_reducing_aux_payment:
        wd_line = None # Inicializar
        try:
            # Acceso como diccionario, que es común para worked_days en reglas
            wd_line = worked_days.get(code_leave) 
        except Exception: # Captura genérica por si .get no es el método
            pass

        if wd_line: 
            current_leave_days = 0.0
            try:
                # Acceso directo a number_of_days
                current_leave_days = float(wd_line.number_of_days or 0.0) 
            except (AttributeError, ValueError, TypeError): 
                pass 
            days_absent_affecting_aux += current_leave_days

days_eligible_for_aux = max(0.0, days_in_month_theory - days_absent_affecting_aux)
result_qty = days_eligible_for_aux

if monthly_transport_subsidy > precision_rounding and days_eligible_for_aux > precision_rounding:
    daily_aux_rate = monthly_transport_subsidy / days_in_month_theory 
    result = daily_aux_rate
    
    # Lógica de Redondeo (la misma que para SALARIO)
    if not (abs(result) < precision_rounding):
        num_decimals = 2 
        if currency_rounding == 0.01: num_decimals = 2
        elif currency_rounding == 1.0: num_decimals = 0
        elif currency_rounding == 10.0: num_decimals = -1 
        elif currency_rounding == 100.0: num_decimals = -2
        
        if num_decimals >= 0:
            factor = 10 ** num_decimals
            result = float(int(result * factor + (0.5 if result >=0 else -0.5))) / factor
        else: 
            factor = 10 ** abs(num_decimals)
            result = float(int(result / factor + (0.5 if result >=0 else -0.5))) * factor
    else:
        result = 0.0
else:
    result = 0.0
    if not (days_eligible_for_aux > precision_rounding): # Si no hay días elegibles
        result_qty = 0.0
        ]]>
    </field>
    <!-- === Campos Específicos Nómina Electrónica Colombia === -->
    <field name="type_concept">earn</field>
    <field name="earn_category">transports_assistance</field>
    <field name="edi_is_detailed" eval="True"/>
    <field name="edi_quantity_select">code</field>
    <field name="edi_percent_select">default</field>
    <field name="co_partner_select">code</field>
    <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
    </field>
</record>

        <!-- ============================================= -->
        <!--      REGLA: HORA EXTRA DIURNA (HED) - ROBUSTECIDA -->
        <!-- ============================================= -->
        <record id="hr_rule_hora_extra_diurna" model="hr.salary.rule">
            <field name="name">Hora Extra Diurna</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">30</field> <!-- Ajustada secuencia -->
            <field name="code">HED</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de HED si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de HED) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de HED) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HED condition ---
result = False
hed_input_amount = 0.0

# Safely get HED hours from inputs
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
hed_input_line = inputs.get('HED')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if hed_input_line and isinstance(hed_input_line.amount, (int, float)):
    hed_input_amount = hed_input_line.amount

# Apply if regular employee and HED hours are positive
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and hed_input_amount > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HED amount ---
result = 0.0
result_qty = 0.0
hed_hours = 0.0

hed_input_line = inputs.get('HED')
if hed_input_line and isinstance(hed_input_line.amount, (int, float)):
    hed_hours = hed_input_line.amount

if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and hed_hours > 0:
    result_qty = hed_hours
    contract_wage = contract.wage

    hourly_rate_divisor = 240.0 
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0

    if hourly_rate > 0:
        default_overtime_percentage = 25.0 # Porcentaje de RECARGO para HED
        overtime_percentage = default_overtime_percentage

        if company_obj and company_obj.daily_overtime is not None:
            company_percentage = company_obj.daily_overtime
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0:
                overtime_percentage = company_percentage
        
        # Calcula el VALOR UNITARIO de una hora extra diurna
        # Valor unitario = valor hora ordinaria * (1 + %recargo/100)
        unit_value = hourly_rate * (1 + (overtime_percentage / 100.0))
        calculated_amount = unit_value # Este es el 'result' (importe unitario)
        
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else: # Fallback rounding
                result = round(calculated_amount, 2) 
        else:
            result = 0.0
else: 
    result = 0.0
    result_qty = 0.0

if abs(result) < precision_rounding:
    result = 0.0
if not (hed_hours > 0): 
    result_qty = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">daily_overtime</field> <!-- Categoría correcta para HED -->
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">HED</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">daily_overtime</field> <!-- Campo correcto en res.company -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>
                              
        <!-- ================================================= -->
        <!--      REGLA: HORA EXTRA NOCTURNA (HEN) - ROBUSTECIDA -->
        <!-- ================================================= -->
        <record id="hr_rule_hora_extra_nocturna" model="hr.salary.rule">
            <field name="name">Hora Extra Nocturna</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">35</field> <!-- Secuencia original, ajustar si es necesario -->
            <field name="code">HEN</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HEN condition ---
result = False
hen_input_amount = 0.0

hen_input_line = inputs.get('HEN')
if hen_input_line and isinstance(hen_input_line.amount, (int, float)):
    hen_input_amount = hen_input_line.amount

if is_regular and hen_input_amount > 0:
    result = True
        ]]>
    </field>
    <field name="amount_select">code</field>
    <field name="amount_python_compute">
        <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0 
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HEN amount ---
result = 0.0
result_qty = 0.0
hen_hours = 0.0

hen_input_line = inputs.get('HEN')
if hen_input_line and isinstance(hen_input_line.amount, (int, float)):
    hen_hours = hen_input_line.amount

if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and hen_hours > 0:
    result_qty = hen_hours
    contract_wage = contract.wage
    
    hourly_rate_divisor = 240.0 
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0

    if hourly_rate > 0:
        default_overtime_percentage = 75.0 # Porcentaje de RECARGO para HEN
        overtime_percentage = default_overtime_percentage

        if company_obj and company_obj.overtime_night_hours is not None:
            company_percentage = company_obj.overtime_night_hours
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0:
                overtime_percentage = company_percentage
        
        # Valor unitario = valor hora ordinaria * (1 + %recargo/100)
        unit_value = hourly_rate * (1 + (overtime_percentage / 100.0))
        calculated_amount = unit_value
        
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else: # Fallback rounding
                result = round(calculated_amount, 2) 
        else:
            result = 0.0
else: 
    result = 0.0
    result_qty = 0.0

if abs(result) < precision_rounding:
    result = 0.0
if not (hen_hours > 0): 
    result_qty = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">overtime_night_hours</field> <!-- Categoría correcta para HEN -->
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">HEN</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">overtime_night_hours</field> <!-- Campo correcto en res.company -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- ============================================= -->
        <!--      REGLA: RECARGO NOCTURNO (RN) - ROBUSTECIDA -->
        <!-- ============================================= -->
        <record id="hr_rule_recargo_nocturno" model="hr.salary.rule">
            <field name="name">Recargo Nocturno</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">40</field> <!-- Ajustada secuencia -->
            <field name="code">RN</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de RN si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de RN) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de RN) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RN condition ---
result = False
rn_input_amount = 0.0

# Safely get RN hours from inputs
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
rn_input_line = inputs.get('RN')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if rn_input_line and isinstance(rn_input_line.amount, (int, float)):
    rn_input_amount = rn_input_line.amount

# Apply if regular employee and RN hours are positive
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and rn_input_amount > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0 
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RN amount ---
result = 0.0
result_qty = 0.0
rn_hours = 0.0

rn_input_line = inputs.get('RN')
if rn_input_line and isinstance(rn_input_line.amount, (int, float)):
    rn_hours = rn_input_line.amount

if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and rn_hours > 0:
    result_qty = rn_hours
    contract_wage = contract.wage
    
    hourly_rate_divisor = 240.0 
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0

    if hourly_rate > 0:
        default_surcharge_percentage = 35.0 # Porcentaje de RECARGO para RN
        surcharge_percentage = default_surcharge_percentage

        if company_obj and company_obj.hours_night_surcharge is not None:
            company_percentage = company_obj.hours_night_surcharge
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0:
                surcharge_percentage = company_percentage
        
        # Valor unitario = valor hora ordinaria * (%recargo/100)
        unit_value = hourly_rate * (surcharge_percentage / 100.0)
        calculated_amount = unit_value
        
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else: # Fallback rounding
                result = round(calculated_amount, 2)
        else:
            result = 0.0
else: 
    result = 0.0
    result_qty = 0.0

if abs(result) < precision_rounding:
    result = 0.0
if not (rn_hours > 0):
    result_qty = 0.0    
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">hours_night_surcharge</field> <!-- Categoría correcta para RN -->
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">RN</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">hours_night_surcharge</field> <!-- Campo correcto en res.company -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>


        <!-- =========================================================== -->
        <!-- REGLA: HORA EXTRA DOMINICAL/FESTIVA DIURNA (HEDDF) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_hora_extra_dom_fest_diurna" model="hr.salary.rule">
            <field name="name">Hora Extra Dominical/Festiva Diurna</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">45</field> <!-- Ajustada secuencia -->
            <field name="code">HEDDF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de HEDDF si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HEDDF condition ---
result = False
heddf_input_amount = 0.0

# Safely get HEDDF hours from inputs
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
heddf_input_line = inputs.get('HEDDF')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if heddf_input_line and isinstance(heddf_input_line.amount, (int, float)):
    heddf_input_amount = heddf_input_line.amount

# Apply if regular employee and HEDDF hours are positive
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and heddf_input_amount > 0:
    result = True
# No se debe asignar result_qty aquí. La condición solo define 'result'.
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0 
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HEDDF amount ---
result = 0.0
result_qty = 0.0
heddf_hours = 0.0

heddf_input_line = inputs.get('HEDDF')
if heddf_input_line and isinstance(heddf_input_line.amount, (int, float)):
    heddf_hours = heddf_input_line.amount

if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and heddf_hours > 0:
    result_qty = heddf_hours
    contract_wage = contract.wage
    
    hourly_rate_divisor = 240.0 
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0

    if hourly_rate > 0:
        default_overtime_percentage = 100.0 
        overtime_percentage = default_overtime_percentage

        if company_obj and company_obj.sunday_holiday_daily_overtime is not None:
            company_percentage = company_obj.sunday_holiday_daily_overtime
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0:
                overtime_percentage = company_percentage
        
        unit_value = hourly_rate * (1 + (overtime_percentage / 100.0))
        calculated_amount = unit_value
        
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else: 
                result = round(calculated_amount, 2)
        else:
            result = 0.0
else: 
    result = 0.0
    result_qty = 0.0

if abs(result) < precision_rounding:
    result = 0.0
if not (heddf_hours > 0):
    result_qty = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">sunday_holiday_daily_overtime</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">HEDDF</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">sunday_holiday_daily_overtime</field> <!-- Asegúrate que este campo existe en res.company y almacena el % total (ej: 100.0) -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>


        <!-- =========================================================== -->
        <!-- REGLA: RECARGO DOMINICAL/FESTIVO DIURNO (RDDF) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_recargo_dom_fest_diurno" model="hr.salary.rule">
            <field name="name">Recargo Dominical/Festivo Diurno</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">50</field> <!-- Ajustada secuencia -->
            <field name="code">RDDF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de RDDF si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de RDDF) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de RDDF) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RDDF condition ---
result = False
rddf_input_amount = 0.0

# Safely get RDDF hours from inputs
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
rddf_input_line = inputs.get('RDDF')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if rddf_input_line and isinstance(rddf_input_line.amount, (int, float)):
    rddf_input_amount = rddf_input_line.amount

# Apply if regular employee and RDDF hours are positive
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and rddf_input_amount > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de RDDF) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RDDF amount ---
result = 0.0
rddf_hours = 0.0

# Safely get RDDF hours from inputs
rddf_input_line = inputs.get('RDDF')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if rddf_input_line and isinstance(rddf_input_line.amount, (int, float)):
    rddf_hours = rddf_input_line.amount

# Proceed only if regular employee, contract, wage, and RDDF hours are valid
# CORRECCIÓN: Eliminar hasattr y usar acceso directo a contract.wage
if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and rddf_hours > 0:
    contract_wage = contract.wage

    # Calculate ordinary hourly rate (assuming 240 hours per month)
    # TODO: Consider making 240.0 a configurable parameter or deriving from work schedule
    hourly_rate_divisor = 240.0
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0 # Avoid division by zero

    if hourly_rate > 0:
        # Get RDDF surcharge percentage from company settings
        # El campo en res.company.py es 'daily_surcharge_hours_sundays_holidays'
        default_surcharge_percentage = 75.0 # Default for RDDF (75% legal)
        surcharge_percentage = default_surcharge_percentage

        # CORRECCIÓN: Eliminar hasattr y usar acceso directo a company_obj.daily_surcharge_hours_sundays_holidays
        if company_obj and company_obj.daily_surcharge_hours_sundays_holidays is not None: # Check if field exists and is not None
            company_percentage = company_obj.daily_surcharge_hours_sundays_holidays
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0: # Percentage can be 0
                surcharge_percentage = company_percentage
            # else: # Logging no permitido aquí
        # else: # Logging no permitido aquí

        # Calculate total RDDF value (ONLY the surcharge amount)
        # Formula: hours * hourly_rate * (percentage/100)
        calculated_amount = rddf_hours * hourly_rate * (surcharge_percentage / 100.0)

        # Standard currency rounding
        # CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else:
                result = round(calculated_amount, 2) # Fallback rounding
        else:
            result = 0.0

# Ensure result is explicitly 0.0 if it's effectively zero after calculations
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0

# Si no hubo horas válidas, asegurar que result_qty también sea 0.0
if not (hed_hours > 0):
    result_qty = 0.0     
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">daily_surcharge_hours_sundays_holidays</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">RDDF</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">daily_surcharge_hours_sundays_holidays</field> <!-- Asegúrate que este campo existe en res.company -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- =================================================================== -->
        <!-- REGLA: HORA EXTRA DOMINICAL/FESTIVA NOCTURNA (HENDF) - ROBUSTECIDA -->
        <!-- =================================================================== -->
        <record id="hr_rule_hora_extra_dom_fest_nocturna" model="hr.salary.rule">
            <field name="name">Hora Extra Dominical/Festiva Nocturna</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">55</field> <!-- Ajustada secuencia -->
            <field name="code">HENDF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de HENDF si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de HENDF) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de HENDF) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HENDF condition ---
result = False
hendf_input_amount = 0.0

# Safely get HENDF hours from inputs
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
hendf_input_line = inputs.get('HENDF')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if hendf_input_line and isinstance(hendf_input_line.amount, (int, float)):
    hendf_input_amount = hendf_input_line.amount

# Apply if regular employee and HENDF hours are positive
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and hendf_input_amount > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0 
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for HENDF amount ---
result = 0.0
result_qty = 0.0
hendf_hours = 0.0

hendf_input_line = inputs.get('HENDF')
if hendf_input_line and isinstance(hendf_input_line.amount, (int, float)):
    hendf_hours = hendf_input_line.amount

if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and hendf_hours > 0:
    result_qty = hendf_hours
    contract_wage = contract.wage
    
    hourly_rate_divisor = 240.0 
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0

    if hourly_rate > 0:
        # Para HENDF, el recargo total es 150% (75% por ser dom/fest + 75% por ser extra nocturna) sobre el valor de la hora ordinaria.
        # Es decir, se paga 2.5 veces una hora ordinaria, o una hora ordinaria + un recargo del 150%.
        default_overtime_percentage = 150.0 
        overtime_percentage = default_overtime_percentage

        if company_obj and company_obj.sunday_night_overtime_holidays is not None:
            company_percentage = company_obj.sunday_night_overtime_holidays
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0:
                overtime_percentage = company_percentage
        
        # Valor unitario = valor hora ordinaria * (1 + %recargo_total/100)
        unit_value = hourly_rate * (1 + (overtime_percentage / 100.0))
        calculated_amount = unit_value
        
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else: # Fallback rounding
                result = round(calculated_amount, 2)
        else:
            result = 0.0
else: 
    result = 0.0
    result_qty = 0.0

if abs(result) < precision_rounding:
    result = 0.0
if not (hendf_hours > 0):
    result_qty = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">sunday_night_overtime_holidays</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">HENDF</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">sunday_night_overtime_holidays</field> <!-- Asegúrate que este campo existe en res.company y almacena el % total (ej: 150.0) -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- =================================================================== -->
        <!-- REGLA: RECARGO DOMINICAL/FESTIVO NOCTURNO (RNDF) - ROBUSTECIDA -->
        <!-- =================================================================== -->
        <record id="hr_rule_recargo_dom_fest_nocturno" model="hr.salary.rule">
            <field name="name">Recargo Dominical/Festivo Nocturno</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">60</field> <!-- Ajustada secuencia -->
            <field name="code">RNDF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de RNDF si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de RNDF) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de RNDF) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RNDF condition ---
result = False
rndf_input_amount = 0.0

# Safely get RNDF hours from inputs
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
rndf_input_line = inputs.get('RNDF')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if rndf_input_line and isinstance(rndf_input_line.amount, (int, float)):
    rndf_input_amount = rndf_input_line.amount

# Apply if regular employee and RNDF hours are positive
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and rndf_input_amount > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5':
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0 
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RNDF amount ---
result = 0.0
result_qty = 0.0
rndf_hours = 0.0

rndf_input_line = inputs.get('RNDF')
if rndf_input_line and isinstance(rndf_input_line.amount, (int, float)):
    rndf_hours = rndf_input_line.amount

if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and rndf_hours > 0:
    result_qty = rndf_hours
    contract_wage = contract.wage
    
    hourly_rate_divisor = 240.0 
    if hourly_rate_divisor > 0:
        hourly_rate = contract_wage / hourly_rate_divisor
    else:
        hourly_rate = 0.0

    if hourly_rate > 0:
        # Para RNDF, el recargo total es 110% (75% por ser dom/fest + 35% por ser nocturno) sobre el valor de la hora ordinaria.
        default_surcharge_percentage = 110.0 
        surcharge_percentage = default_surcharge_percentage

        if company_obj and company_obj.sunday_holidays_night_surcharge_hours is not None:
            company_percentage = company_obj.sunday_holidays_night_surcharge_hours
            if isinstance(company_percentage, (int, float)) and company_percentage >= 0:
                surcharge_percentage = company_percentage
        
        # Valor unitario = valor hora ordinaria * (%recargo_total/100)
        # Este es el valor del RECARGO por hora, no el valor total de la hora pagada.
        unit_value = hourly_rate * (surcharge_percentage / 100.0)
        calculated_amount = unit_value
        
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else: # Fallback rounding
                result = round(calculated_amount, 2)
        else:
            result = 0.0
else: 
    result = 0.0
    result_qty = 0.0

if abs(result) < precision_rounding:
    result = 0.0
if not (rndf_hours > 0):
    result_qty = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">sunday_holidays_night_surcharge_hours</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">RNDF</field>
            <field name="edi_percent_select">default</field>
            <field name="edi_percent_company_field">sunday_holidays_night_surcharge_hours</field> <!-- Asegúrate que este campo existe en res.company y almacena el % total (ej: 110.0) -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: VACACIONES DISFRUTADAS (VACDISF) - ROBUSTECIDA  -->
        <!-- =========================================================== -->
        <record id="hr_rule_vacaciones_disfrutadas_auto" model="hr.salary.rule">
            <field name="name">Vacaciones Disfrutadas</field> <!-- Nombre simplificado -->
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">65</field> <!-- Ajustada secuencia -->
            <field name="code">VACDISF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de VACDISF si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de VACDISF) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de VACDISF) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VACDISF condition ---
result = False
vacation_days = 0.0
# Código del tipo de ausencia para vacaciones disfrutadas (debe coincidir con hr.work.entry.type y hr.leave.type)
vacation_work_entry_code = 'VACDISF'

# Obtener días de vacaciones del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
vacation_line = worked_days.get(vacation_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if vacation_line and isinstance(vacation_line.number_of_days, (int, float)):
    vacation_days = vacation_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de vacaciones > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and vacation_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de VACDISF) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VACDISF amount ---
result = 0.0
vacation_days = 0.0
vacation_work_entry_code = 'VACDISF' # Debe coincidir con el código en condition_python

# Re-obtener días de vacaciones (ya validados en condición, pero buena práctica)
vacation_line = worked_days.get(vacation_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if vacation_line and isinstance(vacation_line.number_of_days, (int, float)):
    vacation_days = vacation_line.number_of_days

# Proceder solo si es empleado regular, contrato, salario base válido y días de vacaciones > 0
# CORRECCIÓN: Eliminar hasattr y usar acceso directo a contract.wage
if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and vacation_days > 0:
    contract_wage = contract.wage

    # TODO: Base de cálculo de vacaciones.
    # La ley indica que es el salario ordinario al momento de disfrutarlas.
    # Para salario variable, es el promedio del último año.
    # Esta implementación simplificada usa el salario base actual del contrato (contract.wage).
    # Considerar un método en hr_payslip.py para un cálculo más preciso de la base de vacaciones.
    # Por ejemplo: base_vacaciones = payslip._get_vacation_base_salary()

    base_salary_for_vacations = contract_wage # Simplificación actual

    if base_salary_for_vacations > 0:
        daily_rate = base_salary_for_vacations / 30.0 # Tarifa diaria siempre sobre 30
        calculated_amount = vacation_days * daily_rate

        # Standard currency rounding
        # CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
        if not (abs(calculated_amount) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(calculated_amount)
            else:
                result = round(calculated_amount, 2) # Fallback rounding
        else:
            result = 0.0

# Ensure result is explicitly 0.0 if it's effectively zero after calculations
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">vacation_common</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">VACDISF</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: VACACIONES COMPENSADAS (VACCD) - ROBUSTECIDA         -->
        <!-- =========================================================== -->
        <record id="hr_rule_vacaciones_compensadas" model="hr.salary.rule">
            <field name="name">Vacaciones Compensadas</field> <!-- Nombre simplificado -->
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">70</field> <!-- Ajustada secuencia -->
            <field name="code">VACCD</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de VACCD si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de VACCD) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de VACCD) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VACCD condition ---
result = False
manual_vacc_value = 0.0
pending_days_input = 0.0

# Check for manual value input 'VACCD'
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
vacc_value_input_line = inputs.get('VACCD')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if vacc_value_input_line and isinstance(vacc_value_input_line.amount, (int, float)):
    manual_vacc_value = vacc_value_input_line.amount

# Check for pending days input 'VACCD_PEND_D' (typically for final settlement)
pending_days_input_line = inputs.get('VACCD_PEND_D')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if pending_days_input_line and isinstance(pending_days_input_line.amount, (int, float)):
    pending_days_input = pending_days_input_line.amount

# Determine if it's a final settlement
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .is_settlement después de verificar que payslip existe
is_final_settlement = payslip.is_settlement if payslip and payslip.is_settlement is not None else False


# Condition:
# Apply if regular employee AND
# ( (it's a final settlement AND there are pending days AND contract wage is valid) OR (a manual value > 0 is provided) )
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular:
    if manual_vacc_value > 0:
        result = True
    # CORRECCIÓN: Eliminar hasattr y usar acceso directo a contract.wage
    elif is_final_settlement and pending_days_input > 0 and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de VACCD) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VACCD amount ---
result = 0.0
manual_vacc_value = 0.0
pending_days_input = 0.0

# Re-fetch inputs (already validated in condition, but good practice)
vacc_value_input_line = inputs.get('VACCD')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if vacc_value_input_line and isinstance(vacc_value_input_line.amount, (int, float)):
    manual_vacc_value = vacc_value_input_line.amount

pending_days_input_line = inputs.get('VACCD_PEND_D')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if pending_days_input_line and isinstance(pending_days_input_line.amount, (int, float)):
    pending_days_input = pending_days_input_line.amount

# CORRECCIÓN: Eliminar hasattr y acceder directamente a .is_settlement después de verificar que payslip existe
is_final_settlement = payslip.is_settlement if payslip and payslip.is_settlement is not None else False


# Priority to manual value input
if manual_vacc_value > 0:
    result = manual_vacc_value
# CORRECCIÓN: Eliminar hasattr y usar acceso directo a contract.wage
elif is_final_settlement and pending_days_input > 0 and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0:
    # Calculate based on pending days if it's a final settlement and no manual value
    contract_wage = contract.wage

    # TODO: Base de cálculo de vacaciones compensadas.
    # La ley indica que es el salario ordinario al momento de la liquidación.
    # Para salario variable, es el promedio del último año.
    # Esta implementación simplificada usa el salario base actual del contrato (contract.wage).
    # Considerar un método en hr_payslip.py para un cálculo más preciso.
    base_salary_for_compensation = contract_wage # Simplificación actual

    if base_salary_for_compensation > 0:
        daily_rate = base_salary_for_compensation / 30.0 # Tarifa diaria siempre sobre 30
        calculated_amount = pending_days_input * daily_rate
        result = calculated_amount

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback rounding
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">vacation_compensated</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">input</field>
            <field name="edi_quantity_input_code">VACCD_PEND_D</field> <!-- Reporta días si el cálculo fue por días -->
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--         REGLA: PRIMA DE SERVICIOS (PRIMA) - ROBUSTECIDA     -->
        <!-- =========================================================== -->
        <record id="hr_rule_prima_servicios" model="hr.salary.rule">
            <field name="name">Prima de Servicios</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">105</field> <!-- Ajustada secuencia -->
            <field name="code">PRIMA</field>
            <field name="category_id" ref="hr_payroll.ALW"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # CORRECCIÓN: Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PRIMA condition ---
result = False

# Aplica si es empleado regular
# is_regular ya está definido en el preámbulo
if is_regular and payslip and payslip.date_to: # Acceso directo a payslip.date_to
    # Determinar si es mes de pago de prima (Junio o Diciembre)
    is_payout_month = payslip.date_to.month in [6, 12]

    # Determinar si es liquidación final (asume campo 'is_settlement' en hr.payslip)
    # CORRECCIÓN: Acceso directo a payslip.is_settlement
    is_final_settlement = payslip.is_settlement if payslip.is_settlement is not None else False

    # La regla se activa si es mes de pago O si es liquidación final
    if is_payout_month or is_final_settlement:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # CORRECCIÓN: Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PRIMA amount ---
# Llama al método definido en hr.payslip (que ya incluye redondeo estándar)
# El método _calculate_prima_servicios() debe manejar la lógica de base y días.
result = 0.0
# is_regular ya está definido en el preámbulo
if is_regular: # Doble verificación, aunque la condición ya lo hizo.
    try:
        # Asumimos que _calculate_prima_servicios está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_prima_servicios no existe o no es accesible, esto fallará y será capturado por Exception.
        if payslip: # Asegurarse que payslip existe
            result = payslip._calculate_prima_servicios()
    except Exception as e:
        # _logger.error("Error calculando PRIMA: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>     
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">primas</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field> <!-- La cantidad de días se maneja internamente en el cálculo -->
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: CÁLCULO CESANTÍAS (CESANTIA_CALC) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_cesantias_calculo" model="hr.salary.rule">
            <field name="name">Cálculo Cesantías</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">106</field> <!-- Ajustada secuencia -->
            <field name="code">CESANTIA_CALC</field>
            <field name="category_id" ref="hr_payroll.ALW"/> <!-- O COMP si es solo cómputo -->
            <field name="condition_select">python</field>
            <field name="condition_python">
               <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for CESANTIA_CALC condition ---
result = False

# Aplica si es empleado regular y es Diciembre o Liquidación Final
if is_regular and payslip and payslip.date_to:
    is_december = payslip.date_to.month == 12
    is_final_settlement = payslip.is_settlement if payslip.is_settlement is not None else False

    if is_december or is_final_settlement:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for CESANTIA_CALC amount ---
# Llama al método definido en hr.payslip (que ya incluye redondeo estándar)
# El método _calculate_cesantias() debe manejar la lógica de base y días.
result = 0.0
if is_regular: # Doble verificación, aunque la condición ya lo hizo.
    try:
        if payslip: # Asegurarse que payslip existe
            result = payslip._calculate_cesantias()
    except Exception as e:
        # Si necesitas depurar, temporalmente podrías asignar str(e) a result
        # para ver el error en la nómina, pero recuerda quitarlo para producción.
        # Ejemplo: result = -9999 # O un valor que indique error
        # O si tienes un campo de log en la nómina: payslip.log_message = str(e)
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/> <!-- Es un cálculo, no un pago directo aquí -->
            <!-- Los campos EDI son más relevantes para CESANTIA_PAY si es liquidación -->
            <!-- <field name="type_concept">earn</field> -->
            <!-- <field name="earn_category">layoffs</field> -->
            <!-- <field name="edi_is_detailed" eval="False"/> -->
            <!-- <field name="edi_quantity_select">default</field> -->
            <!-- <field name="edi_percent_select">default</field> -->
            <!-- <field name="co_partner_select">default</field> -->
        </record>

        <!-- =========================================================== -->
        <!--    REGLA: PAGO CESANTÍAS EN LIQUIDACIÓN (CESANTIA_PAY) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_cesantias_pago_liquidacion" model="hr.salary.rule">
            <field name="name">Pago Cesantías Liquidación</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">107</field> <!-- Ajustada secuencia -->
            <field name="code">CESANTIA_PAY</field>
            <field name="category_id" ref="hr_payroll.ALW"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # CORRECCIÓN: Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for CESANTIA_PAY condition ---
result = False
calculated_cesantias = categories.get('CESANTIA_CALC', 0.0) # Obtener valor de la regla de cálculo

# Aplica si es empleado regular, es liquidación final y se calcularon cesantías
# CORRECCIÓN: Acceso directo a payslip.is_settlement y reemplazo de float_is_zero
is_final_settlement = False
if payslip and payslip.is_settlement is not None: # Asumimos que is_settlement es un campo booleano en hr.payslip
    is_final_settlement = bool(payslip.is_settlement)

# is_regular ya está definido en el preámbulo
if is_regular and is_final_settlement and not (abs(calculated_cesantias) < precision_rounding):
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # CORRECCIÓN: Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for CESANTIA_PAY amount ---
# Tomar el valor calculado por la regla CESANTIA_CALC (ya está redondeado)
result = categories.get('CESANTIA_CALC', 0.0)

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="True"/>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">layoffs</field> <!-- Cesantías pagadas en liquidación -->
            <field name="edi_is_detailed" eval="False"/> <!-- El valor ya es el total -->
            <field name="edi_quantity_select">default</field> <!-- La cantidad de días se maneja internamente en el cálculo de CESANTIA_CALC -->
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field> <!-- El pago es al empleado -->
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: INTERESES A LAS CESANTÍAS (INTCES) - ROBUSTECIDA     -->
        <!-- =========================================================== -->
        <record id="hr_rule_intereses_cesantias" model="hr.salary.rule">
            <field name="name">Intereses a las Cesantías</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">108</field> <!-- Ajustada secuencia -->
            <field name="code">INTCES</field>
            <field name="category_id" ref="hr_payroll.ALW"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # CORRECCIÓN: Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for INTCES condition ---
result = False
# Obtener valor de la regla de cálculo de cesantías
# categories es un diccionario con los resultados de reglas de menor secuencia
calculated_cesantias = categories.get('CESANTIA_CALC', 0.0)

# Aplica si es empleado regular y se calcularon cesantías (CESANTIA_CALC > 0)
# (CESANTIA_CALC ya se activa en Diciembre o Liquidación Final)
# is_regular ya está definido en el preámbulo
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if is_regular and not (abs(calculated_cesantias) < precision_rounding):
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # CORRECCIÓN: Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # CORRECCIÓN: Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for INTCES amount ---
# Llama al método definido en hr.payslip (que ya incluye redondeo estándar)
# El método _calculate_intereses_cesantias() debe usar categories.get('CESANTIA_CALC') internamente.
result = 0.0
# is_regular ya está definido en el preámbulo
if is_regular: # Doble verificación, aunque la condición ya lo hizo.
    try:
        # Asumimos que _calculate_intereses_cesantias está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_intereses_cesantias no existe o no es accesible, esto fallará y será capturado por Exception.
        if payslip: # Asegurarse que payslip existe
            result = payslip._calculate_intereses_cesantias()
    except Exception as e:
        # _logger.error("Error calculando INTCES: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="True"/>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">layoffs_interest</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field>
            <field name="edi_percent_fix">12.0</field> <!-- Porcentaje anual legal -->
            <field name="co_partner_select">default</field> <!-- El pago es al empleado -->
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: LICENCIA MATERNIDAD/PATERNIDAD (LMA) - ROBUSTECIDA   -->
        <!-- =========================================================== -->
        <record id="hr_rule_licencia_maternidad_paternidad" model="hr.salary.rule">
            <field name="name">Licencia Maternidad/Paternidad</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">72</field> <!-- Ajustada secuencia -->
            <field name="code">LMA</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de LMA si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de LMA) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de LMA) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LMA condition ---
result = False
lma_days = 0.0
# Código del tipo de ausencia para LMA (debe coincidir con hr.work.entry.type y hr.leave.type)
lma_work_entry_code = 'LMA'

# Obtener días de LMA del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
lma_line = worked_days.get(lma_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if lma_line and isinstance(lma_line.number_of_days, (int, float)):
    lma_days = lma_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de LMA > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and lma_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de LMA) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LMA amount ---
result = 0.0
lma_days = 0.0
lma_work_entry_code = 'LMA' # Debe coincidir con el código en condition_python

# Re-obtener días de LMA (ya validados en condición)
lma_line = worked_days.get(lma_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if lma_line and isinstance(lma_line.number_of_days, (int, float)):
    lma_days = lma_line.number_of_days

# Llama al método definido en hr.payslip para calcular el subsidio
# Este método debe manejar la lógica de base (IBC mes anterior, etc.) y redondeo.
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and lma_days > 0: # Doble verificación
    try:
        # Asumimos que _calculate_lma_subsidy está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_lma_subsidy no existe o no es accesible, esto fallará.
        if hasattr(payslip, '_calculate_lma_subsidy'): # Verificación segura de la existencia del método
            result = payslip._calculate_lma_subsidy(lma_days)
        else:
            # _logger.error("Método _calculate_lma_subsidy no encontrado en payslip.") # Logging no permitido
            result = 0.0 # Fallback si el método no existe
    except Exception as e:
        # _logger.error("Error calculando LMA: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">licensings_maternity_or_paternity_leaves</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">LMA</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field> <!-- El % (100%) está implícito en el cálculo del subsidio -->
            <field name="co_partner_select">default</field> <!-- El pago es al empleado, la empresa recobra a la EPS -->
        </record>

        <!-- =========================================================== -->
        <!--         REGLA: PERMISO REMUNERADO (LR) - ROBUSTECIDA        -->
        <!-- =========================================================== -->
        <record id="hr_rule_permiso_remunerado" model="hr.salary.rule">
            <field name="name">Permiso Remunerado</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">73</field> <!-- Ajustada secuencia -->
            <field name="code">LR</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de LR si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de LR) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de LR) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LR condition ---
result = False
lr_days = 0.0
# Código del tipo de ausencia para LR (debe coincidir con hr.work.entry.type y hr.leave.type)
lr_work_entry_code = 'LR'

# Obtener días de LR del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
lr_line = worked_days.get(lr_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if lr_line and isinstance(lr_line.number_of_days, (int, float)):
    lr_days = lr_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de LR > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and lr_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de LR) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LR amount ---
result = 0.0
lr_days = 0.0
lr_work_entry_code = 'LR' # Debe coincidir con el código en condition_python

# Re-obtener días de LR (ya validados en condición)
lr_line = worked_days.get(lr_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if lr_line and isinstance(lr_line.number_of_days, (int, float)):
    lr_days = lr_line.number_of_days

# Proceder solo si es empleado regular, contrato, salario base válido y días de LR > 0
# CORRECCIÓN: Eliminar hasattr y usar acceso directo a contract.wage
if is_regular and contract and contract.wage and isinstance(contract.wage, (int, float)) and contract.wage > 0 and lr_days > 0:
    contract_wage = contract.wage
    
    # Cálculo simple: salario / 30 * días del permiso
    daily_rate = contract_wage / 30.0 # Tarifa diaria siempre sobre 30
    calculated_amount = lr_days * daily_rate
    
    # Standard currency rounding
    # CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
    if not (abs(calculated_amount) < precision_rounding):
        if payslip and payslip.currency_id:
            result = payslip.currency_id.round(calculated_amount)
        else:
            result = round(calculated_amount, 2) # Fallback rounding
    else:
        result = 0.0

# Ensure result is explicitly 0.0 if it's effectively zero after calculations
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">licensings_permit_or_paid_licenses</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">LR</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field> <!-- Empleador paga -->
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: INCAPACIDAD GENERAL Días 1-2 (IGE1_2) - ROBUSTECIDA  -->
        <!-- =========================================================== -->
        <record id="hr_rule_ige_1_2" model="hr.salary.rule">
            <field name="name">Incapacidad General Días 1-2</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">74</field> <!-- Ajustada secuencia -->
            <field name="code">IGE1_2</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de IGE1_2 si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de IGE1_2) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de IGE1_2) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE1_2 condition ---
result = False
ige1_2_days = 0.0
# Código del tipo de ausencia para IGE1_2 (debe coincidir con hr.work.entry.type y hr.leave.type)
ige1_2_work_entry_code = 'IGE1_2'

# Obtener días de IGE1_2 del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
ige1_2_line = worked_days.get(ige1_2_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige1_2_line and isinstance(ige1_2_line.number_of_days, (int, float)):
    ige1_2_days = ige1_2_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de IGE1_2 > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige1_2_days > 0:
    result = True

                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de IGE1_2) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE1_2 amount ---
result = 0.0
ige1_2_days = 0.0
ige1_2_work_entry_code = 'IGE1_2' # Debe coincidir con el código en condition_python

# Re-obtener días de IGE1_2 (ya validados en condición)
ige1_2_line = worked_days.get(ige1_2_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige1_2_line and isinstance(ige1_2_line.number_of_days, (int, float)):
    ige1_2_days = ige1_2_line.number_of_days

# Llama al método definido en hr.payslip para calcular el subsidio
# Este método debe manejar la lógica de base (IBC mes anterior, etc.) y redondeo.
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige1_2_days > 0: # Doble verificación
    try:
        # El método _calculate_ige_subsidy_by_code debe estar preparado para 'IGE1_2'
        # Asumimos que _calculate_ige_subsidy_by_code está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_ige_subsidy_by_code no existe o no es accesible, esto fallará.
        if hasattr(payslip, '_calculate_ige_subsidy_by_code'): # Verificación segura de la existencia del método
            result = payslip._calculate_ige_subsidy_by_code(ige1_2_work_entry_code, ige1_2_days)
        else:
            # _logger.error("Método _calculate_ige_subsidy_by_code no encontrado en payslip.") # Logging no permitido
            result = 0.0 # Fallback si el método no existe
    except Exception as e:
        # _logger.error("Error calculando IGE1_2: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">incapacities_common</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">IGE1_2</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field> <!-- El % (66.67%) está implícito en el cálculo del subsidio -->
            <field name="co_partner_select">default</field> <!-- Empleador paga estos días -->
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: INCAPACIDAD GENERAL Días 3-90 (IGE3_90) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_ige_3_90" model="hr.salary.rule">
            <field name="name">Incapacidad General Días 3-90</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">75</field> <!-- Ajustada secuencia -->
            <field name="code">IGE3_90</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de IGE3_90 si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de IGE3_90) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de IGE3_90) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE3_90 condition ---
result = False
ige3_90_days = 0.0
# Código del tipo de ausencia para IGE3_90 (debe coincidir con hr.work.entry.type y hr.leave.type)
ige3_90_work_entry_code = 'IGE3_90'

# Obtener días de IGE3_90 del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
ige3_90_line = worked_days.get(ige3_90_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige3_90_line and isinstance(ige3_90_line.number_of_days, (int, float)):
    ige3_90_days = ige3_90_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de IGE3_90 > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige3_90_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado y CORREGIDO)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination (CORREGIDA a la versión que usa type_worker_id.code) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    try:
        if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
            is_integral = True
    except AttributeError: pass # is_integral permanece False
    
    try: # CORRECTO: Usa type_worker_id.code y códigos DIAN '12' y '19'
        if contract.type_worker_id and contract.type_worker_id.code:
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass # variables de aprendiz permanecen False
        
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values (con try-except para conversiones numéricas) ---
smmlv = 0.0
uvt_value = 0.0 # Aunque no se use directamente en IGE3_90, es parte del preámbulo común
is_exonerated_company = False # No se usa en este cálculo de monto, pero parte de un preámbulo común
company_obj = None

try:
    if contract: # Acceso defensivo
        company_obj = contract.company_id
except AttributeError: pass

if company_obj:
    try: # Para smmlv_value
        smmlv_from_company = company_obj.smmlv_value # Asumimos que el campo existe
        temp_smmlv = float(smmlv_from_company or 0.0) # Intenta convertir, usa 0.0 si es None
        if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError): smmlv = 0.0 # Fallback si no existe o no es convertible
    
    try: # Para uvt_value
        uvt_from_company = company_obj.uvt_value # Asumimos que el campo existe
        temp_uvt = float(uvt_from_company or 0.0)
        if temp_uvt > 0: uvt_value = temp_uvt
    except (AttributeError, ValueError, TypeError): uvt_value = 0.0
    
    try: # Para ley_1607 (exoneración)
        is_exonerated_company = bool(company_obj.ley_1607) # Asumimos que el campo existe
    except AttributeError: is_exonerated_company = False

# --- Common helper variables (como en tu código de Salario) ---
currency_rounding = 0.01 # Default
precision_rounding = 0.01 # Default
try:
    # Acceso directo a los atributos, asumiendo que existen si los objetos padres existen.
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding = payslip.currency_id.rounding
        test_float = float(current_payslip_currency_rounding) # Intenta convertir
        if 0.0 <= test_float <= 1.0 : # Validación del valor de redondeo
            currency_rounding = test_float
            precision_rounding = test_float
except (AttributeError, ValueError, TypeError):
    # Si hay AttributeError (campo no existe) o error de conversión, se mantienen los defaults.
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE3_90 amount ---
result = 0.0
result_qty = 0.0 # Inicializar la cantidad de días

ige3_90_days_from_wd = 0.0 # Días obtenidos de worked_days
ige3_90_work_entry_code = 'IGE3_90' # Código de la entrada de tiempo

# Obtener los días de IGE3_90 desde worked_days de forma segura
if worked_days:
    wd_line = None
    try:
        wd_line = worked_days.get(ige3_90_work_entry_code) # Intenta obtener la línea de worked_days
        if wd_line: # Si la línea existe
            num_days_val = wd_line.number_of_days # Asumimos que el atributo existe
            try:
                ige3_90_days_from_wd = float(num_days_val or 0.0)
            except (ValueError, TypeError):
                ige3_90_days_from_wd = 0.0 # Si no es convertible, días = 0
    except (AttributeError, KeyError):
        ige3_90_days_from_wd = 0.0 # Si hay error al acceder, días = 0

# Llama al método definido en hr.payslip para calcular el subsidio
# Ahora, 'calculated_amount' debe ser el *valor total* para la incapacidad.
# Para que Odoo multiplique correctamente, debemos establecer 'result' como el valor unitario (diario).
if is_regular and (ige3_90_days_from_wd > precision_rounding):
    try:
        # Esto nos devuelve el valor total para los días de IGE3_90
        total_ige_subsidy = payslip._calculate_ige_subsidy_by_code(ige3_90_work_entry_code, ige3_90_days_from_wd)
        
        if ige3_90_days_from_wd > 0:
            # Calculamos el valor unitario (por día) dividiendo el total entre la cantidad de días.
            # Este es el valor que Odoo usará como 'Amount' y luego multiplicará por 'Quantity'.
            result = total_ige_subsidy / ige3_90_days_from_wd
        else:
            result = 0.0 # Evitar división por cero
            
        result_qty = ige3_90_days_from_wd # Asignar los días a result_qty
        
        # Aplicar el redondeo al valor unitario si es necesario (similar a SALARIO)
        if not (abs(result) < precision_rounding): 
            num_decimals = 2 
            if currency_rounding == 0.01: num_decimals = 2
            elif currency_rounding == 1.0: num_decimals = 0
            elif currency_rounding == 10.0: num_decimals = -1 
            elif currency_rounding == 100.0: num_decimals = -2
            
            if num_decimals >= 0:
                factor = 10 ** num_decimals
                result = float(int(result * factor + (0.5 if result >=0 else -0.5))) / factor
            else: 
                factor = 10 ** abs(num_decimals)
                result = float(int(result / factor + (0.5 if result >=0 else -0.5))) * factor
        else:
            result = 0.0 # Si el valor es muy pequeño, se deja en cero
            
    except AttributeError:
        result = 0.0
        result_qty = 0.0 
    except Exception as e: 
        result = 0.0
        result_qty = 0.0
else:
    result = 0.0
    result_qty = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">incapacities_common</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">IGE3_90</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field> <!-- El % (66.67%) está implícito en el cálculo del subsidio -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- ============================================================= -->
        <!-- REGLA: INCAPACIDAD GENERAL Días 91-180 (IGE91_180) - ROBUSTECIDA -->
        <!-- ============================================================= -->
        <record id="hr_rule_ige_91_180" model="hr.salary.rule">
            <field name="name">Incapacidad General Días 91-180</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">76</field> <!-- Ajustada secuencia -->
            <field name="code">IGE91_180</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de IGE91_180 si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de IGE91_180) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de IGE91_180) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE91_180 condition ---
result = False
ige91_180_days = 0.0
# Código del tipo de ausencia para IGE91_180 (debe coincidir con hr.work.entry.type y hr.leave.type)
ige91_180_work_entry_code = 'IGE91_180'

# Obtener días de IGE91_180 del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
ige91_180_line = worked_days.get(ige91_180_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige91_180_line and isinstance(ige91_180_line.number_of_days, (int, float)):
    ige91_180_days = ige91_180_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de IGE91_180 > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige91_180_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de IGE91_180) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE91_180 amount ---
result = 0.0
ige91_180_days = 0.0
ige91_180_work_entry_code = 'IGE91_180' # Debe coincidir con el código en condition_python

# Re-obtener días de IGE91_180 (ya validados en condición)
ige91_180_line = worked_days.get(ige91_180_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige91_180_line and isinstance(ige91_180_line.number_of_days, (int, float)):
    ige91_180_days = ige91_180_line.number_of_days

# Llama al método definido en hr.payslip para calcular el subsidio
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige91_180_days > 0: # Doble verificación
    try:
        # El método _calculate_ige_subsidy_by_code debe estar preparado para 'IGE91_180'
        # Asumimos que _calculate_ige_subsidy_by_code está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_ige_subsidy_by_code no existe o no es accesible, esto fallará.
        # No usamos hasattr aquí para evitar posibles NameErrors. Confiamos en que el método existe.
        result = payslip._calculate_ige_subsidy_by_code(ige91_180_work_entry_code, ige91_180_days)
    except AttributeError:
        # Esto se capturaría si _calculate_ige_subsidy_by_code no existe en payslip
        # _logger.error("Método _calculate_ige_subsidy_by_code no encontrado en payslip.") # Logging no permitido
        result = 0.0 # Fallback si el método no existe
    except Exception as e:
        # _logger.error("Error calculando IGE91_180: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">incapacities_common</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">IGE91_180</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field> <!-- El % (50%) está implícito en el cálculo del subsidio -->
            <field name="co_partner_select">default</field> <!-- El pago en nómina es al empleado, la empresa recobra a la EPS -->
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: INCAPACIDAD GENERAL Días 181+ (IGE181_MAS) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_ige_181_mas" model="hr.salary.rule">
            <field name="name">Incapacidad General Días 181+</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">77</field> <!-- Ajustada secuencia -->
            <field name="code">IGE181_MAS</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de IGE181_MAS si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de IGE181_MAS) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de IGE181_MAS) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE181_MAS condition ---
result = False
ige181_mas_days = 0.0
# Código del tipo de ausencia para IGE181_MAS (debe coincidir con hr.work.entry.type y hr.leave.type)
ige181_mas_work_entry_code = 'IGE181_MAS'

# Obtener días de IGE181_MAS del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
ige181_mas_line = worked_days.get(ige181_mas_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige181_mas_line and isinstance(ige181_mas_line.number_of_days, (int, float)):
    ige181_mas_days = ige181_mas_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de IGE181_MAS > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige181_mas_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de IGE181_MAS) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IGE181_MAS amount ---
result = 0.0
ige181_mas_days = 0.0
ige181_mas_work_entry_code = 'IGE181_MAS' # Debe coincidir con el código en condition_python

# Re-obtener días de IGE181_MAS (ya validados en condición)
ige181_mas_line = worked_days.get(ige181_mas_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if ige181_mas_line and isinstance(ige181_mas_line.number_of_days, (int, float)):
    ige181_mas_days = ige181_mas_line.number_of_days

# Llama al método definido en hr.payslip para calcular el subsidio
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and ige181_mas_days > 0: # Doble verificación
    try:
        # El método _calculate_ige_subsidy_by_code debe estar preparado para 'IGE181_MAS'
        # Asumimos que _calculate_ige_subsidy_by_code está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_ige_subsidy_by_code no existe o no es accesible, esto fallará.
        # No usamos hasattr aquí para evitar posibles NameErrors. Confiamos en que el método existe.
        result = payslip._calculate_ige_subsidy_by_code(ige181_mas_work_entry_code, ige181_mas_days)
    except AttributeError:
        # Esto se capturaría si _calculate_ige_subsidy_by_code no existe en payslip
        # _logger.error("Método _calculate_ige_subsidy_by_code no encontrado en payslip.") # Logging no permitido
        result = 0.0 # Fallback si el método no existe
    except Exception as e:
        # _logger.error("Error calculando IGE181_MAS: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">incapacities_common</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">IGE181_MAS</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field> <!-- El % (50%) está implícito en el cálculo del subsidio -->
            <field name="co_partner_select">code</field> <!-- El pago en nómina es al empleado, la empresa recobra al Fondo de Pensiones -->
            <field name="co_partner_python_compute">
                <![CDATA[
# Partner es el Fondo de Pensión asignado en el contrato
result = contract.pension_id.partner_id.id if contract and contract.pension_id and contract.pension_id.partner_id else None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: INCAPACIDAD LABORAL (ATEP) - ROBUSTECIDA        -->
        <!-- =========================================================== -->
        <record id="hr_rule_incapacidad_laboral" model="hr.salary.rule">
            <field name="name">Incapacidad Laboral (AT/EP)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">78</field> <!-- Ajustada secuencia -->
            <field name="code">ATEP</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
# No necesitamos los tipos específicos de aprendiz para la condición de ATEP si solo nos importa is_any_apprentice
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4' or contract_type_code == '5': # Es aprendiz si es tipo 4 o 5
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de ATEP) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values (No necesarios para la condición de ATEP) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ATEP condition ---
result = False
atep_days = 0.0
# Código del tipo de ausencia para ATEP (debe coincidir con hr.work.entry.type y hr.leave.type)
atep_work_entry_code = 'ATEP'

# Obtener días de ATEP del objeto worked_days
# worked_days es un diccionario donde la clave es el código del Work Entry Type
# y el valor es el objeto hr.payslip.worked_days.line
atep_line = worked_days.get(atep_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if atep_line and isinstance(atep_line.number_of_days, (int, float)):
    atep_days = atep_line.number_of_days

# La condición es verdadera si es empleado regular y hay días de ATEP > 0
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and atep_days > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Necesario si el cálculo depende del tipo de empleado (aunque la condición ya filtra)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de ATEP) ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ATEP amount ---
result = 0.0
atep_days = 0.0
atep_work_entry_code = 'ATEP' # Debe coincidir con el código en condition_python

# Re-obtener días de ATEP (ya validados en condición)
atep_line = worked_days.get(atep_work_entry_code)
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .number_of_days después de verificar que la línea existe
if atep_line and isinstance(atep_line.number_of_days, (int, float)):
    atep_days = atep_line.number_of_days

# Llama al método definido en hr.payslip para calcular el subsidio
# CORRECCIÓN: Usar la variable is_regular del preámbulo
if is_regular and atep_days > 0: # Doble verificación
    try:
        # El método _calculate_atep_subsidy debe estar preparado para calcular el 100% del IBC
        # Asumimos que _calculate_atep_subsidy está definido en tu modelo hr.payslip
        # y que es accesible a través del objeto payslip.
        # Si _calculate_atep_subsidy no existe o no es accesible, esto fallará.
        # No usamos hasattr aquí para evitar posibles NameErrors. Confiamos en que el método existe.
        result = payslip._calculate_atep_subsidy(atep_days)
    except AttributeError:
        # Esto se capturaría si _calculate_atep_subsidy no existe en payslip
        # _logger.error("Método _calculate_atep_subsidy no encontrado en payslip.") # Logging no permitido
        result = 0.0 # Fallback si el método no existe
    except Exception as e:
        # _logger.error("Error calculando ATEP: %s", str(e)) # Logging no permitido
        result = 0.0

# Asegurar que el resultado sea explícitamente 0.0 si es efectivamente cero
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">incapacities_working</field>
            <field name="edi_is_detailed" eval="True"/>
            <field name="edi_quantity_select">worked_days</field>
            <field name="edi_quantity_worked_days_code">ATEP</field> <!-- Código del hr.work.entry.type -->
            <field name="edi_percent_select">default</field> <!-- El % (100%) está implícito en el cálculo del subsidio -->
            <field name="co_partner_select">code</field> <!-- El pago en nómina es al empleado, la empresa recobra a la ARL -->
            <field name="co_partner_python_compute">
                <![CDATA[
# Partner es la ARL asignada en el contrato
result = contract.arl_id.partner_id.id if contract and hasattr(contract, 'arl_id') and contract.arl_id and contract.arl_id.partner_id else None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: BONIFICACIÓN SALARIAL (BON_S - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_bonificacion_salarial" model="hr.salary.rule">
            <field name="name">Bonificación Salarial</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">80</field> <!-- Ajustada secuencia -->
            <field name="code">BON_S</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BON_S condition ---
result = False
# Aplica si es empleado regular y existe un item recurrente activo para esta regla.
if is_regular: # is_regular ya está definido en el preámbulo
    # payslip.env está disponible en el contexto de las reglas
    RecurringItem = payslip.env.get('hr.employee.recurring.item')
    if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
        domain = [
            ('employee_id', '=', employee.id),
            ('contract_id', '=', contract.id),
            ('recurring_item_type_id.salary_rule_id', '=', rule.id),
            ('active', '=', True),
            ('date_start', '<=', payslip.date_to),
            '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
            '|', ('use_installments', '=', False),
                 '&', ('use_installments', '=', True),
                      '|', ('remaining_installments', '>', 0),
                           ('remaining_balance', '>', 0.0)
        ]
        # search_count está disponible en el modelo
        if RecurringItem.search_count(domain) > 0:
            result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BON_S amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback to amount if no base rule code
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        # La actualización del saldo/cuotas del item recurrente debería manejarse
        # idealmente fuera de la regla salarial (ej. en el modelo hr.employee.recurring.item
        # o mediante una acción posterior a la confirmación de la nómina).

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback rounding
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">bonuses</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =================================================================== -->
        <!-- REGLA: BONIFICACIÓN NO SALARIAL (BON_NS - Recurrente) - ROBUSTECIDA -->
        <!-- =================================================================== -->
        <record id="hr_rule_bonificacion_no_salarial" model="hr.salary.rule">
            <field name="name">Bonificación No Salarial</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">81</field> <!-- Ajustada secuencia -->
            <field name="code">BON_NS</field>
            <field name="category_id" ref="hr_payroll.ALW"/> <!-- Allowance -->
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BON_NS condition ---
result = False
# Aplica si es empleado regular y existe un item recurrente activo para esta regla.
if is_regular: # is_regular ya está definido en el preámbulo
    # payslip.env está disponible en el contexto de las reglas
    RecurringItem = payslip.env.get('hr.employee.recurring.item')
    if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
        domain = [
            ('employee_id', '=', employee.id),
            ('contract_id', '=', contract.id),
            ('recurring_item_type_id.salary_rule_id', '=', rule.id),
            ('active', '=', True),
            ('date_start', '<=', payslip.date_to),
            '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
            '|', ('use_installments', '=', False),
                 '&', ('use_installments', '=', True),
                      '|', ('remaining_installments', '>', 0),
                           ('remaining_balance', '>', 0.0)
        ]
        # search_count está disponible en el modelo
        if RecurringItem.search_count(domain) > 0:
            result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BON_NS amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback to amount if no base rule code
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        # La actualización del saldo/cuotas del item recurrente debería manejarse
        # idealmente fuera de la regla salarial (ej. en el modelo hr.employee.recurring.item
        # o mediante una acción posterior a la confirmación de la nómina).

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback rounding
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">bonuses_non_salary</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--            REGLA: COMISIONES (COMISION) - ROBUSTECIDA       -->
        <!-- =========================================================== -->
        <record id="hr_rule_comisiones" model="hr.salary.rule">
            <field name="name">Comisiones</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">62</field>
            <field name="code">COMISION</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination (No parece necesario para la condición de COMISION si solo depende del input) ---
# is_regular = False
# is_integral = False
# is_any_apprentice = False
# if contract:
#     if contract.integral_salary:
#         is_integral = True
#     elif contract.contract_type_id and contract.contract_type_id.code:
#         contract_type_code = contract.contract_type_id.code
#         if contract_type_code == '4' or contract_type_code == '5':
#             is_any_apprentice = True
#     if not is_integral and not is_any_apprentice:
#         is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de COMISION) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de COMISION) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COMISION condition ---
result = False
comision_value = 0.0
# inputs es un diccionario donde la clave es el código del Input Type
# y el valor es el objeto hr.payslip.input
comision_input_obj = inputs.get('COMISION')

# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if comision_input_obj and isinstance(comision_input_obj.amount, (int, float)):
    comision_value = comision_input_obj.amount

# La condición es simplemente si el valor de la comisión es mayor que cero.
# No se necesita la variable is_regular aquí a menos que las comisiones solo apliquen a empleados regulares.
# Si ese es el caso, descomenta la parte de 'Employee Type Determination' y añade 'is_regular and' a la condición.
if comision_value > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination (No parece necesario para el cálculo de COMISION si solo toma el input) ---
# is_regular = False
# is_integral = False
# is_any_apprentice = False
# if contract:
#     if contract.integral_salary:
#         is_integral = True
#     elif contract.contract_type_id and contract.contract_type_id.code:
#         contract_type_code = contract.contract_type_id.code
#         if contract_type_code == '4' or contract_type_code == '5':
#             is_any_apprentice = True
#     if not is_integral and not is_any_apprentice:
#         is_regular = True

# --- Fetching key values from categories (No necesarios para el cálculo de COMISION) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para el cálculo de COMISION) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero si se aplica redondeo
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COMISION amount ---
result = 0.0
comision_input_obj = inputs.get('COMISION') # 'inputs' es un dict de objetos hr.payslip.input

# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if comision_input_obj and isinstance(comision_input_obj.amount, (int, float)):
    result = comision_input_obj.amount

# El valor de entrada ya debería tener la precisión correcta.
# No se aplica redondeo adicional aquí, se toma el valor de entrada tal cual.
# Si se quisiera forzar un redondeo (aunque usualmente no es necesario para inputs directos):
# # CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
# if not (abs(result) < precision_rounding):
#     if payslip and payslip.currency_id:
#         result = payslip.currency_id.round(result)
#     else:
#         result = round(result, 2) # Fallback
# else:
#     result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">commissions</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--   REGLA: COMPENSACIÓN ORDINARIA (COMP_ORD - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_compensacion_ordinaria" model="hr.salary.rule">
            <field name="name">Compensación Ordinaria</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">70</field>
            <field name="code">COMP_ORD</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================

is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if hasattr(contract, 'integral_salary') and contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if hasattr(company_obj, 'smmlv_value') and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if hasattr(company_obj, 'uvt_value') and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if hasattr(company_obj, 'ley_1607'):
        is_exonerated_company = bool(company_obj.ley_1607)

currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COMP_ORD condition ---
result = False
# Aplica si existe un item recurrente activo para esta regla.
# La lógica de tipo de empleado (is_regular, etc.) podría usarse aquí si el concepto solo aplica a ciertos tipos.
# Por ahora, se asume que si el item recurrente existe y está activo, la condición es True.
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem:
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Busca por la regla actual (COMP_ORD)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
from odoo.tools import float_is_zero, float_compare
# import math
# import logging
# _logger = logging.getLogger(__name__)

is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if hasattr(contract, 'integral_salary') and contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if hasattr(company_obj, 'smmlv_value') and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if hasattr(company_obj, 'uvt_value') and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if hasattr(company_obj, 'ley_1607'):
        is_exonerated_company = bool(company_obj.ley_1607)

currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COMP_ORD amount ---
result = 0.0
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem:
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback si no hay código de regla base, usar el monto del item como base (o definir otro comportamiento)
                base_value = recurring_item.amount
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # NOTA IMPORTANTE: La actualización del saldo restante (remaining_balance)
        # o las cuotas restantes (remaining_installments) del 'recurring_item'
        # NO debe hacerse aquí. Debe manejarse después de que la nómina se confirme,
        # por ejemplo, en un método _post_process_payslip_lines() en hr.payslip.

# Standard currency rounding
if not float_is_zero(result, precision_rounding=precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">compensations_ordinary</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: COMPENSACIÓN EXTRAORDINARIA (COMP_EXT - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_compensacion_extraordinaria" model="hr.salary.rule">
            <field name="name">Compensación Extraordinaria</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">71</field>
            <field name="code">COMP_EXT</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de COMP_EXT
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de COMP_EXT si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de COMP_EXT si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COMP_EXT condition ---
result = False
# This rule applies if a recurring item is active for it.
# Employee type checks (e.g., is_regular) could be added here if the concept
# itself is restricted, beyond just the existence of the recurring item.

# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (COMP_EXT)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular:
        #     result = True
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de COMP_EXT
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COMP_EXT amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating the remaining_balance or remaining_installments
        # of the 'recurring_item' should NOT be done here. It should be handled
        # after the payslip is confirmed.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">compensations_extraordinary</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: VALES GENÉRICOS (VOUCHER - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_vales_genericos" model="hr.salary.rule">
            <field name="name">Vales Genéricos</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">72</field>
            <field name="code">VOUCHER</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de VOUCHER
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de VOUCHER si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de VOUCHER si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER condition ---
result = False
# This rule applies if a recurring item is active for it.
# Employee type checks (e.g., is_regular) could be added here if the concept
# itself is restricted, beyond just the existence of the recurring item.

# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (VOUCHER)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular:
        #     result = True
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de VOUCHER
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating the remaining_balance or remaining_installments
        # of the 'recurring_item' should NOT be done here. It should be handled
        # after the payslip is confirmed.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">vouchers</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: VALES NO SALARIALES (VOUCHER_NS - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <record id="hr_rule_vales_no_salariales" model="hr.salary.rule">
            <field name="name">Vales No Salariales</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">73</field>
            <field name="code">VOUCHER_NS</field>
            <field name="category_id" ref="hr_payroll.ALW"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de VOUCHER_NS
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de VOUCHER_NS si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de VOUCHER_NS si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER_NS condition ---
result = False
# This rule applies if a recurring item is active for it.
# Employee type checks (e.g., is_regular) could be added here if the concept
# itself is restricted, beyond just the existence of the recurring item.

# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (VOUCHER_NS)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular:
        #     result = True
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de VOUCHER_NS
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER_NS amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating the remaining_balance or remaining_installments
        # of the 'recurring_item' should NOT be done here. It should be handled
        # after the payslip is confirmed.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">vouchers_non_salary</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: VALES ALIMENTACIÓN SALARIALES (VOUCHER_SF - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_vales_alimentacion_salariales" model="hr.salary.rule">
            <field name="name">Vales Alimentación Salariales</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">74</field>
            <field name="code">VOUCHER_SF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de VOUCHER_SF
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de VOUCHER_SF si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de VOUCHER_SF si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER_SF condition ---
result = False
# Optional: Uncomment if this concept only applies to regular employees
# if not is_regular:
#     result = False
# else:
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (VOUCHER_SF)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de VOUCHER_SF
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER_SF amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating recurring item balance/installments should be handled post-payslip confirmation.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">vouchers_salary_food</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: VALES ALIMENTACIÓN NO SALARIALES (VOUCHER_NSF - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_vales_alimentacion_no_salariales" model="hr.salary.rule">
            <field name="name">Vales Alimentación No Salariales</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">75</field>
            <field name="code">VOUCHER_NSF</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de VOUCHER_NSF
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de VOUCHER_NSF si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de VOUCHER_NSF si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER_NSF condition ---
result = False
# Optional: Uncomment if this concept only applies to regular employees
# if not is_regular:
#     result = False
# else:
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (VOUCHER_NSF)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente

                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de VOUCHER_NSF
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VOUCHER_NSF amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating recurring item balance/installments should be handled post-payslip confirmation.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">vouchers_non_salary_food</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: AUXILIO SALARIAL (ASSIST - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_auxilio_salarial" model="hr.salary.rule">
            <field name="name">Auxilio Salarial</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">76</field>
            <field name="code">ASSIST</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de ASSIST
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de ASSIST si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de ASSIST si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ASSIST condition ---
result = False
# Optional: Uncomment if this concept only applies to regular employees
# if not is_regular:
#     result = False
# else:
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (ASSIST)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de ASSIST
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ASSIST amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating recurring item balance/installments should be handled post-payslip confirmation.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">assistances</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>


        <!-- =========================================================== -->
        <!-- REGLA: AUXILIO NO SALARIAL (ASSIST_NS - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_auxilio_no_salarial" model="hr.salary.rule">
            <field name="name">Auxilio No Salarial</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">77</field>
            <field name="code">ASSIST_NS</field>
            <field name="category_id" ref="hr_payroll.ALW"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de ASSIST_NS
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de ASSIST_NS si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (No necesarios para la condición de ASSIST_NS si solo depende del item recurrente) ---
# smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
#         smmlv = company_obj.smmlv_value
#     if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
#         uvt_value = company_obj.uvt_value
#     if company_obj.ley_1607:
#         is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ASSIST_NS condition ---
result = False
# Optional: Uncomment if this concept only applies to regular employees
# if not is_regular:
#     result = False
# else:
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (ASSIST_NS)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de ASSIST_NS
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # Access UVT safely
    # Asumimos que el campo 'uvt_value' existe en res.company
    if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Access Ley 1607 exoneration flag safely
    # Asumimos que el campo 'ley_1607' existe en res.company y es booleano
    if company_obj.ley_1607:
        is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ASSIST_NS amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating recurring item balance/installments should be handled post-payslip confirmation.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">assistances_non_salary</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>


        <!-- =========================================================== -->
        <!-- REGLA: DOTACIÓN EN DINERO (DOTACION - Recurrente) - ROBUSTECIDA -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_dotacion" model="hr.salary.rule">
            <field name="name">Dotación (Pago en Dinero)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">78</field>
            <field name="code">DOTACION</field>
            <field name="category_id" ref="hr_payroll.BASIC"/> <!-- Considerar ALW si es estrictamente no salarial -->
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si la aplicabilidad de DOTACION
# depende del tipo de empleado (is_regular, is_integral, etc.)
# o de su salario en relación con SMMLV, lo cual se manejaría mejor
# al crear el item recurrente o en una lógica más compleja aquí.
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Check for Integral first
    # Asumimos que el campo 'integral_salary' existe en hr.contract
    if contract.integral_salary: # Si el campo existe y es True
        is_integral = True
    # Then check for Apprentice types if not Integral
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories (No necesarios para la condición de DOTACION si solo depende del item recurrente) ---
# ibc = categories.get('IBC', 0.0)

# --- Company specific values (SMMLV podría ser relevante si la condición de dotación se basa en él) ---
smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
    #     uvt_value = company_obj.uvt_value
    # if company_obj.ley_1607:
    #     is_exonerated_company = True

# --- Common helper variables (Solo precision_rounding podría ser útil si la condición compara con cero) ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for DOTACION condition ---
result = False
# La lógica de a quién aplica la dotación (ej. empleados que ganan hasta X SMMLV)
# debería estar implícita en la creación del item recurrente o verificada aquí si es necesario.
# Aquí solo verificamos si el item recurrente existe y está activo.

# Ejemplo de verificación adicional (si la dotación solo aplica a regulares que ganan menos de 2 SMMLV):
# condition_met_for_dotacion = False
# if is_regular and contract and contract.wage and smmlv > 0:
#     if contract.wage <= (2 * smmlv):
#         condition_met_for_dotacion = True
#
# if not condition_met_for_dotacion:
#     result = False # No aplica la dotación por política salarial
# else:
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (DOTACION)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
                '&', ('use_installments', '=', True),
                    '|', ('remaining_installments', '>', 0),
                        ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True # El item recurrente existe y está activo
# else: # Si RecurringItem no se pudo obtener (aunque debería estar siempre disponible via env)
#     result = False
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
# Esta parte del preámbulo podría ser necesaria si el cálculo de DOTACION
# depende del tipo de empleado (is_regular, is_integral, etc.)
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Asumimos que el campo 'integral_salary' existe
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Podría ser necesario si el porcentaje se basa en IBC

# --- Company specific values ---
smmlv = 0.0
# uvt_value = 0.0
# is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Access SMMLV safely
    # Asumimos que el campo 'smmlv_value' existe en res.company
    if company_obj.smmlv_value and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    # if company_obj.uvt_value and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
    #     uvt_value = company_obj.uvt_value
    # if company_obj.ley_1607:
    #     is_exonerated_company = True

# --- Common helper variables ---
# precision_rounding se usará para la comparación con cero
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding

# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for DOTACION amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback if no base rule code, use the item's amount as base
                base_value = recurring_item.amount # Asumiendo que 'amount' es la base si no hay código de regla
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        
        # IMPORTANT NOTE: Updating recurring item balance/installments should be handled post-payslip confirmation.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">endowment</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: APOYO SOSTENIMIENTO (APOYO_SOST - Revisado Auto)     -->
        <!-- =========================================================== -->
        <record id="hr_rule_apoyo_sostenimiento" model="hr.salary.rule">
            <field name="name">Apoyo Sostenimiento (Aprendiz SENA)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">79</field>
            <field name="code">APOYO_SOST</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <!-- Condición: Aplicar si el tipo de trabajador es Aprendiz SENA (lectiva o productiva) -->
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env
# --- Python Built-ins ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination (Basado en Tipo de Trabajador DIAN desde el Contrato) ---
is_regular = False 
is_integral = False 
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: 
    if contract.integral_salary: 
        is_integral = True
    
    if contract.type_worker_id and contract.type_worker_id.code: # Usa el campo del contrato
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': 
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif dian_worker_type_code == '19': 
            is_apprentice_productiva = True
            is_any_apprentice = True

if not is_integral and not is_any_apprentice:
    is_regular = True
# --- Company specific values (smmlv es el único necesario aquí del preámbulo APOYO_SOST original) ---
smmlv = 0.0
company_obj = None
if contract and contract.company_id: 
    company_obj = contract.company_id
if company_obj:
    smmlv_from_company = company_obj.smmlv_value 
    temp_smmlv = 0.0
    try: 
        temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0
# --- Common helper variables ---
# (precision_rounding se definirá en amount_python_compute si es necesario para la condición, aquí no se usa)
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for APOYO_SOST condition ---
result = False
if is_apprentice_lectiva or is_apprentice_productiva: 
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <!-- Cálculo Automático: % SMMLV según etapa, prorrateado por días a liquidar, con override manual -->
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3) - Reaplicado aquí
# ======================================================
# --- Environment objects (Automatically available) ---
# --- Python Built-ins --- (Como arriba)

# --- Employee Type Determination (Basado en Tipo de Trabajador DIAN desde el Contrato) ---
is_apprentice_lectiva = False
is_apprentice_productiva = False
# is_any_apprentice no es estrictamente necesario aquí si solo usamos las específicas
if contract: # Asumimos que 'contract' está disponible en el contexto de amount_python_compute
    if contract.type_worker_id and contract.type_worker_id.code: # Usa el campo del contrato
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': 
            is_apprentice_lectiva = True
        elif dian_worker_type_code == '19': 
            is_apprentice_productiva = True
# --- Company specific values ---
smmlv = 0.0
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id
if company_obj:
    smmlv_from_company = company_obj.smmlv_value 
    temp_smmlv = 0.0
    try: 
        temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0
# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : 
            currency_rounding = test_float
            precision_rounding = test_float
    except (ValueError, TypeError): pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for APOYO_SOST amount ---
result = 0.0
result_qty = 0.0 
days_to_liquidate_apoyo = 30.0 

manual_support_value = 0.0
manual_input_provided = False
apoyo_sost_input_line = inputs.get('APOYO_SOST') if inputs else None

if apoyo_sost_input_line:
    raw_input_amount = None
    try:
        raw_input_amount = apoyo_sost_input_line.amount 
    except Exception: 
        pass
        
    temp_manual_amount = 0.0
    if raw_input_amount is not None:
        try:
            temp_manual_amount = float(raw_input_amount or 0.0)
        except (ValueError, TypeError):
            pass 
    
    if temp_manual_amount > precision_rounding: 
        manual_support_value = temp_manual_amount
        manual_input_provided = True

if manual_input_provided:
    result = manual_support_value
    result_qty = 1.0 
else:
    base_apoyo_mensual = 0.0
    if contract: 
        contract_wage_value = 0.0
        try:
            contract_wage_value = float(contract.wage or 0.0) 
        except (ValueError, TypeError):
            pass
        if contract_wage_value > precision_rounding:
            base_apoyo_mensual = contract_wage_value
    
    if not (base_apoyo_mensual > precision_rounding): 
        if smmlv > precision_rounding: 
            percentage = 0.0
            if is_apprentice_lectiva: 
                percentage = 0.50 
            elif is_apprentice_productiva: 
                percentage = 0.75 
            
            if percentage > 0:
                base_apoyo_mensual = smmlv * percentage
    
    unpaid_leave_codes = ['LNR', 'SUS'] 
    unpaid_leave_days = 0.0
    if worked_days:
        for code_ul in unpaid_leave_codes:
            wd_line = worked_days.get(code_ul)
            if wd_line:
                current_ul_days = 0.0
                try:
                    current_ul_days = float(wd_line.number_of_days or 0.0) 
                except (ValueError, TypeError):
                    pass
                unpaid_leave_days += current_ul_days
    
    days_to_liquidate_apoyo = max(0.0, 30.0 - unpaid_leave_days)
    result_qty = days_to_liquidate_apoyo

    if days_to_liquidate_apoyo > precision_rounding and base_apoyo_mensual > precision_rounding:
        daily_rate_apoyo = base_apoyo_mensual / 30.0
        result = daily_rate_apoyo 
    else:
        result = 0.0
        result_qty = 0.0

# Redondeo final para 'result'
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) 
else:
    result = 0.0

if not (result_qty > precision_rounding): 
    result_qty = 0.0
    result = 0.0 
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">sustainment_support</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">code</field> <!-- Reportar % aplicado -->
            <field name="edi_percent_python_compute">
                <![CDATA[
# Preamble para obtener smmlv, is_apprentice_lectiva, is_apprentice_productiva
is_apprentice_lectiva = False
is_apprentice_productiva = False
smmlv = 0.0

if contract: # Asumimos que 'contract' está disponible
    if contract.type_worker_id and contract.type_worker_id.code: # Usa el campo del contrato
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': is_apprentice_lectiva = True
        elif dian_worker_type_code == '19': is_apprentice_productiva = True
    
    company_obj = contract.company_id if contract.company_id else None
    if company_obj:
        smmlv_from_company = company_obj.smmlv_value
        temp_smmlv = 0.0
        try: temp_smmlv = float(smmlv_from_company)
        except (ValueError, TypeError): pass
        if temp_smmlv > 0: smmlv = temp_smmlv
# ======================================================
result = 0.0 
if is_apprentice_lectiva:
    result = 50.0 
elif is_apprentice_productiva:
    result = 75.0 
                ]]>
            </field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: AUXILIO TELETRABAJO (TELEWORK_AUX - Recurrente)      -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_auxilio_teletrabajo" model="hr.salary.rule">
            <field name="name">Auxilio Teletrabajo</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">80</field>
            <field name="code">TELEWORK_AUX</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for TELEWORK_AUX condition ---
result = False
# This rule applies if a recurring item is active for it.
# Employee type checks (e.g., is_regular) could be added here if the concept
# itself is restricted, beyond just the existence of the recurring item.

# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (TELEWORK_AUX)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO import math # Eliminado a menos que se use math.ceil o similar
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for TELEWORK_AUX amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)

        # --- Consider Prorrateo (Descomentar y ajustar si es necesario) ---
        prorate = False # Cambia a True si necesitas prorratear
        if prorate:
             # Calcular días a liquidar (base 30 - ausencias no remuneradas)
             days_to_liquidate = 30.0
             worked_days_dict = {wd.code: wd for wd in worked_days.values()} if worked_days else {}
             unpaid_leave_codes = ['LNR', 'SUS'] # Ajustar si es necesario
             unpaid_leave_days = 0.0
             for code_unpaid in unpaid_leave_codes:
                 wd_line = worked_days_dict.get(code_unpaid)
                 if wd_line and wd_line.number_of_days is not None: # Acceso directo
                     try: unpaid_leave_days += float(wd_line.number_of_days or 0.0)
                     except (ValueError, TypeError): pass
             days_to_liquidate = max(0.0, 30.0 - unpaid_leave_days)

             if days_to_liquidate > 0 and amount_to_pay > 0:
                 result = (amount_to_pay / 30.0) * days_to_liquidate
             else:
                 result = 0.0
        else:
             result = amount_to_pay # Si no se prorratea, usar directamente
        # --- Fin Considerar Prorrateo ---

        # La actualización del saldo/cuotas del item recurrente debe manejarse
        # idealmente fuera de la regla salarial (ej. en una acción posterior).

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">telecommuting</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: BONIFICACIÓN POR RETIRO (BON_RETIRO)            -->
        <!-- =========================================================== -->
        <record id="hr_rule_bonificacion_retiro" model="hr.salary.rule">
            <field name="name">Bonificación por Retiro</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">81</field>
            <field name="code">BON_RETIRO</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BON_RETIRO condition ---
result = False
bon_retiro_value = 0.0

# Safely get BON_RETIRO value from inputs
# inputs es un diccionario de objetos hr.payslip.input
bon_retiro_input_line = inputs.get('BON_RETIRO')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if bon_retiro_input_line and bon_retiro_input_line.amount is not None:
    try:
        bon_retiro_value = float(bon_retiro_input_line.amount or 0.0)
    except (ValueError, TypeError):
        bon_retiro_value = 0.0

# Check if it's a final settlement
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .is_settlement después de verificar que payslip existe
is_final_settlement = False
if payslip and payslip.is_settlement is not None: # Asumimos que is_settlement es un campo booleano en hr.payslip
    is_final_settlement = bool(payslip.is_settlement)

# Condition: Applies only in final settlement AND if a positive value is provided in the input.
if is_final_settlement and bon_retiro_value > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BON_RETIRO amount ---
result = 0.0

# Safely get BON_RETIRO value from inputs (already validated in condition, but good practice)
bon_retiro_input_line = inputs.get('BON_RETIRO')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if bon_retiro_input_line and bon_retiro_input_line.amount is not None:
    try:
        result = float(bon_retiro_input_line.amount or 0.0)
    except (ValueError, TypeError):
        result = 0.0

# No additional rounding needed as it's taken directly from input.
# Ensure it's explicitly 0.0 if it was not a valid number or zero.
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">company_withdrawal_bonus</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--            REGLA: REINTEGRO (REINTEGRO)                     -->
        <!-- =========================================================== -->
        <record id="hr_rule_reintegro" model="hr.salary.rule">
            <field name="name">Reintegro</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">82</field>
            <field name="code">REINTEGRO</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for REINTEGRO condition ---
result = False
reintegro_value = 0.0

# Safely get REINTEGRO value from inputs
# inputs es un diccionario de objetos hr.payslip.input
reintegro_input_line = inputs.get('REINTEGRO')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if reintegro_input_line and reintegro_input_line.amount is not None:
    try:
        reintegro_value = float(reintegro_input_line.amount or 0.0)
    except (ValueError, TypeError):
        reintegro_value = 0.0

# Condition: Applies if a positive value is provided in the input.
if reintegro_value > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for REINTEGRO amount ---
result = 0.0

# Safely get REINTEGRO value from inputs (already validated in condition)
reintegro_input_line = inputs.get('REINTEGRO')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if reintegro_input_line and reintegro_input_line.amount is not None:
    try:
        result = float(reintegro_input_line.amount or 0.0)
    except (ValueError, TypeError):
        result = 0.0

# No additional rounding needed as it's taken directly from input.
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">refund</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: VIÁTICO SALARIAL (VIATICO_S - Recurrente)       -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_viatico_salarial" model="hr.salary.rule">
            <field name="name">Viático Salarial (Manutención y Alojamiento)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">83</field>
            <field name="code">VIATICO_S</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VIATICO_S condition ---
result = False
# This rule applies if a recurring item is active for it.
# Employee type checks (e.g., is_regular) could be added here if the concept
# itself is restricted, beyond just the existence of the recurring item.

# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (VIATICO_S)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VIATICO_S amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        # La actualización del saldo/cuotas del item recurrente debe manejarse
        # idealmente fuera de la regla salarial.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">transports_viatic</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: VIÁTICO NO SALARIAL (VIATICO_NS - Recurrente)        -->
        <!-- =========================================================== -->
        <!-- Requiere modelo hr.employee.recurring.item -->
        <record id="hr_rule_viatico_no_salarial" model="hr.salary.rule">
            <field name="name">Viático No Salarial (Transporte y Representación)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">84</field>
            <field name="code">VIATICO_NS</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VIATICO_NS condition ---
result = False
# This rule applies if a recurring item is active for it.

# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Searches for current rule (VIATICO_NS)
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        # Adicionalmente, podrías querer verificar 'is_regular' si solo aplica a ellos
        # if is_regular: # Descomentar si es necesario
        result = True # Por ahora, solo depende del item recurrente
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for VIATICO_NS amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_pay = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_pay = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_pay = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_pay = min(amount_to_pay, recurring_item.remaining_balance)
        
        result = amount_to_pay
        # La actualización del saldo/cuotas del item recurrente debe manejarse
        # idealmente fuera de la regla salarial.

# Standard currency rounding
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">transports_non_salary_viatic</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--        REGLA: OTRO CONCEPTO SALARIAL (OTRO_S)               -->
        <!-- =========================================================== -->
        <record id="hr_rule_otro_concepto_salarial" model="hr.salary.rule">
            <field name="name">Otro Concepto Salarial</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">90</field>
            <field name="code">OTRO_S</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for OTRO_S condition ---
result = False
otro_s_value = 0.0

# Safely get OTRO_S value from inputs
# inputs es un diccionario de objetos hr.payslip.input
otro_s_input_line = inputs.get('OTRO_S')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if otro_s_input_line and otro_s_input_line.amount is not None:
    try:
        otro_s_value = float(otro_s_input_line.amount or 0.0)
    except (ValueError, TypeError):
        otro_s_value = 0.0

# Condition: Applies if a positive value is provided in the input.
if otro_s_value > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for OTRO_S amount ---
result = 0.0

# Safely get OTRO_S value from inputs (already validated in condition)
otro_s_input_line = inputs.get('OTRO_S')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if otro_s_input_line and otro_s_input_line.amount is not None:
    try:
        result = float(otro_s_input_line.amount or 0.0)
    except (ValueError, TypeError):
        result = 0.0

# No additional rounding needed as it's taken directly from input.
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">other_concepts</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: OTRO CONCEPTO NO SALARIAL (OTRO_NS)             -->
        <!-- =========================================================== -->
        <record id="hr_rule_otro_concepto_no_salarial" model="hr.salary.rule">
            <field name="name">Otro Concepto No Salarial</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">91</field>
            <field name="code">OTRO_NS</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for OTRO_NS condition ---
result = False
otro_ns_value = 0.0

# Safely get OTRO_NS value from inputs
# inputs es un diccionario de objetos hr.payslip.input
otro_ns_input_line = inputs.get('OTRO_NS')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if otro_ns_input_line and otro_ns_input_line.amount is not None:
    try:
        otro_ns_value = float(otro_ns_input_line.amount or 0.0)
    except (ValueError, TypeError):
        otro_ns_value = 0.0

# Condition: Applies if a positive value is provided in the input.
if otro_ns_value > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# NO 'from odoo.tools import float_is_zero, float_compare'
# NO 'import math'
# NO 'import logging'
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary: # Acceso directo
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True
            is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: # Acceso directo
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for OTRO_NS amount ---
result = 0.0

# Safely get OTRO_NS value from inputs (already validated in condition)
otro_ns_input_line = inputs.get('OTRO_NS')
# CORRECCIÓN: Eliminar hasattr y acceder directamente a .amount después de verificar que la línea existe
if otro_ns_input_line and otro_ns_input_line.amount is not None:
    try:
        result = float(otro_ns_input_line.amount or 0.0)
    except (ValueError, TypeError):
        result = 0.0

# No additional rounding needed as it's taken directly from input.
# CORRECCIÓN: Reemplazar float_is_zero con la comparación manual
if abs(result) < precision_rounding:
    result = 0.0
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">earn</field>
            <field name="earn_category">other_concepts_non_salary</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>


        <!-- =========================================================== -->
        <!--      REGLA: Total Ingresos Devengados (TOTAL_DEV) - AJUSTADA     -->
        <!-- =========================================================== -->
        <record id="hr_rule__total_ingresos_devengados" model="hr.salary.rule">
            <field name="name">Total Ingresos Devengados</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">99</field> 
            <field name="code">TOTAL_DEV</field>
            <field name="category_id" ref="hr_payroll.GROSS"/> 
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
result = categories.get('IBC', 0.0) + categories.get('BASE_PRESTACIONES', 0.0) + categories.get('BASIC', 0.0) + categories.get('LIC_INC', 0.0)
result = round(result, 0)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: INGRESO BASE DE COTIZACIÓN (IBC) - AJUSTADA     -->
        <!-- =========================================================== -->
        <record id="hr_rule_ingreso_base_cotizacion" model="hr.salary.rule">
            <field name="name">Ingreso Base de Cotización (IBC)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">100</field> <!-- Ajustar si es necesario. Debe ser MAYOR que las reglas que componen el IBC. -->
            <field name="code">IBC</field>
            <field name="category_id" ref="hr_payroll.BASIC"/> <!-- Categoría para cómputos/bases -->
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - CORREGIDO)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.

# --- Employee Type Determination (CORREGIDO para Aprendices) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: # Asumimos que 'contract' existe
    try: # Para contract.integral_salary
        if contract.integral_salary: # Campo booleano 'Salario integral'
            is_integral = True
    except AttributeError:
        pass # is_integral permanece False

    try: # Para contract.type_worker_id.code (Tipos de trabajador DIAN)
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass # variables de aprendiz permanecen False
            
    # Determina si es regular (ni integral, ni aprendiz)
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- El resto del preámbulo (smmlv, uvt, exonerated, currency_rounding, precision_rounding) ---
# --- se mantiene como lo tienes, ya que no afecta la lógica de activación del IBC ---
# --- y ya usa acceso directo y try-except donde es necesario.                 ---

# --- Company specific values (acceso directo y try-except) ---
smmlv = 0.0
# uvt_value = 0.0 # No se usa en la condición específica del IBC
# is_exonerated_company = False # No se usa en la condición específica del IBC
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0 
    # No necesitamos uvt_value ni is_exonerated_company para la condición de la regla IBC.

# --- Common helper variables (precision_rounding se usa implícitamente si float_is_zero fuera usado) ---
# precision_rounding = 0.01 # Default
# try: 
#     if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
#         current_payslip_currency_rounding_val = payslip.currency_id.rounding
#         temp_float_rounding = float(current_payslip_currency_rounding_val)
#         if 0.0 <= temp_float_rounding <= 1.0 : 
#             precision_rounding = temp_float_rounding
# except (AttributeError, ValueError, TypeError):
#     pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IBC condition ---
# La regla IBC se aplica si el empleado NO es aprendiz.
# El cálculo del IBC (en el método _calculate_ibc o en amount_python_compute)
# diferenciará entre regular e integral.
result = False
if contract and not is_any_apprentice:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# No se necesita el preámbulo completo aquí, ya que el método _calculate_ibc
# del objeto payslip tiene acceso a todo su entorno (contract, company, etc.)
# y la variable 'categories' es inyectada por Odoo en este contexto.
# Este es el código que llama al método Python en hr_payslip.py

result = 0.0
if payslip: # Asegurarse que payslip existe
    try:
        result = payslip._calculate_ibc(categories)
    except Exception as e:
        # Considera registrar el error si tienes un logger configurado en hr_payslip.py
        # o temporalmente levantar un UserError para ver el error 'e' en la UI.
        # from odoo.exceptions import UserError
        # raise UserError(f"Error llamando a _calculate_ibc: {str(e)}")
        result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: Base Prestaciones Sociales (TOTAL_RETENCION)     -->
        <!-- =========================================================== -->
        <record id="hr_rule__base_prestaciones_sociales_auxilio" model="hr.salary.rule">
            <field name="name">Base Prestaciones Sociales (Con Aux. Trans.)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">103</field> 
            <field name="code">TOTAL_RETENCION</field>
            <field name="category_id" ref="hr_payroll.BASIC"/> 
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - CORREGIDO)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.

# --- Employee Type Determination (CORREGIDO para Aprendices) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: # Asumimos que 'contract' existe
    try: # Para contract.integral_salary
        if contract.integral_salary: # Campo booleano 'Salario integral'
            is_integral = True
    except AttributeError:
        pass # is_integral permanece False

    try: # Para contract.type_worker_id.code (Tipos de trabajador DIAN)
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass # variables de aprendiz permanecen False
            
    # Determina si es regular (ni integral, ni aprendiz)
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- El resto del preámbulo (smmlv, uvt, exonerated, currency_rounding, precision_rounding) ---
# --- se mantiene como lo tienes, ya que no afecta la lógica de activación del IBC ---
# --- y ya usa acceso directo y try-except donde es necesario.                 ---

# --- Company specific values (acceso directo y try-except) ---
smmlv = 0.0
# uvt_value = 0.0 # No se usa en la condición específica del IBC
# is_exonerated_company = False # No se usa en la condición específica del IBC
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0 
    # No necesitamos uvt_value ni is_exonerated_company para la condición de la regla IBC.

# --- Common helper variables (precision_rounding se usa implícitamente si float_is_zero fuera usado) ---
# precision_rounding = 0.01 # Default
# try: 
#     if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
#         current_payslip_currency_rounding_val = payslip.currency_id.rounding
#         temp_float_rounding = float(current_payslip_currency_rounding_val)
#         if 0.0 <= temp_float_rounding <= 1.0 : 
#             precision_rounding = temp_float_rounding
# except (AttributeError, ValueError, TypeError):
#     pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for IBC condition ---
# La regla IBC se aplica si el empleado NO es aprendiz.
# El cálculo del IBC (en el método _calculate_ibc o en amount_python_compute)
# diferenciará entre regular e integral.
result = False
if contract and not is_any_apprentice:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
result = categories.get('IBC', 0.0) + categories.get('BASE_PRESTACIONES', 0.0) + categories.get('BASIC', 0.0)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
        </record>

        <!-- ============================================= -->
        <!-- REGLA: Deducción Salud Empleado (Reg/Int) -->
        <!-- Código: SALUD_EMP o SALUD_EMP_REG -->
        <!-- ============================================= -->
        <record id="hr_rule_deduction_salud_empleado_reg_int" model="hr.salary.rule">
            <field name="name">Deducción Salud Empleado (4%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">109</field> <!-- Secuencia después de bases y devengos -->
            <field name="code">SALUD_EMP</field> <!-- O SALUD_EMP_REG si prefieres un código más específico -->
            <field name="category_id" ref="hr_payroll.DED"/> <!-- Categoría Deducción -->
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: # Asumimos que 'contract' existe
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': 
                is_apprentice_lectiva = True; is_any_apprentice = True
            elif worker_type_code_dian == '19': 
                is_apprentice_productiva = True; is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) 

# --- Common helper variables ---
precision_rounding = 0.01 
try: 
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALUD_EMP condition ---
result = False
eps_fund_assigned = False
try:
    if contract and contract.eps_id: 
        eps_fund_assigned = True
except AttributeError:
    pass 

if eps_fund_assigned:
    # Aplica a Regulares o Integrales con IBC > 0
    if (is_regular or is_integral) and not (abs(ibc) < precision_rounding): 
        result = True
# No aplica a Aprendices (cubierto por la definición de is_regular/is_integral)lica a Aprendices (ya cubierto por is_regular/is_integral que dependen de is_any_apprentice)
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# Preámbulo mínimo si necesitas precision_rounding o currency_rounding para el redondeo manual
precision_rounding = 0.01 
currency_rounding = 0.01 # O la lógica para obtenerlo de payslip.currency_id
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        # ... (lógica para obtener currency_rounding y precision_rounding) ...
        pass 
except: pass

base_para_deduccion = categories.get('CALCULO', 0.0) # Obtiene el IBC final
result = 0.0

if not (abs(base_para_deduccion) < precision_rounding):
    monto_calculado = base_para_deduccion * 0.04 # 4% para salud empleado
    # ... (tu lógica de redondeo manual para result, si es necesaria) ...
    # Ejemplo simple de redondeo manual:
    num_decimals = 2 # Para COP, usualmente 0 si es al peso, o 2 si manejas centavos
    if currency_rounding == 1.0: num_decimals = 0 
    
    if num_decimals >= 0:
        factor = 10 ** num_decimals
        result = float(int(monto_calculado * factor + (0.5 if monto_calculado >=0 else -0.5))) / factor
    else: 
        result = monto_calculado # O redondeo a decenas/centenas si aplica

result = abs(result)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="True"/> <!-- Debe aparecer en la colilla -->
            <field name="type_concept">deduction</field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="deduction_category">health</field> <!-- Código DIAN para Salud -->
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field> <!-- Reportar % fijo -->
            <field name="edi_percent_fix">4.0</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                 <![CDATA[
# ======================================================
# Preámbulo Mínimo para co_partner_python_compute
# Solo 'contract' es necesario aquí.
# ======================================================
result = None # Por defecto, no hay partner
try:
    # Acceso directo a los campos anidados.
    # Si algún campo intermedio no existe o es None (ej. eps_id no está asignada),
    # se producirá AttributeError y result permanecerá None.
    if contract and contract.eps_id and contract.eps_id.partner_id:
        result = contract.eps_id.partner_id.id
except AttributeError:
    result = None # Asegurar que result es None si hay error de atributo
                 ]]>
             </field>
        </record>


        <!-- ============================================= -->
        <!-- REGLA: Deducción Salud Empleado (Aprendiz Prod. 4%) -->
        <!-- ============================================= -->
        <record id="hr_rule_deduction_salud_empleado_aprendiz" model="hr.salary.rule">
            <field name="name">Deducción Salud Empleado (Aprendiz Prod. 4%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">110</field> 
            <field name="code">SALUD_EMP_APR</field> 
            <field name="category_id" ref="hr_payroll.DED"/> 
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env
# --- Python Built-ins ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination (Basado en Tipo de Trabajador DIAN desde el Contrato) ---
is_regular = False 
is_integral = False 
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False # No se usa directamente en esta condición, pero se define por consistencia

if contract: 
    if contract.integral_salary: 
        is_integral = True
    
    # Identificación de aprendiz basada en type_worker_id del contrato
    if contract.type_worker_id and contract.type_worker_id.code: 
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': 
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif dian_worker_type_code == '19': 
            is_apprentice_productiva = True
            is_any_apprentice = True

if not is_integral and not is_any_apprentice:
    is_regular = True

# --- Fetching key values from categories ---
apoyo_sost = categories.get('APOYO_SOST', 0.0) # APOYO_SOST (seq 79) - DISPONIBLE para SALUD_EMP_APR (seq 110)

# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : 
            currency_rounding = test_float
            precision_rounding = test_float
    except (ValueError, TypeError): pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALUD_EMP_APR condition ---
result = False
# is_apprentice_productiva y apoyo_sost son del preámbulo
# Verificar que contract.eps_id exista y tenga valor (no es None ni False)
if contract and contract.eps_id: 
    if is_apprentice_productiva and not (abs(apoyo_sost) < precision_rounding): # apoyo_sost > 0
        result = True 
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3) - Reaplicado aquí
# ======================================================
# --- Environment objects (Automatically available) ---
# --- Python Built-ins --- (Como arriba)
# --- Employee Type Determination (No es necesario redefinir aquí si la condición ya filtró) ---
# --- Fetching key values from categories ---
apoyo_sost = categories.get('APOYO_SOST', 0.0)
# --- Company specific values (smmlv no se usa directamente en este cálculo, pero por consistencia de preámbulo) ---
smmlv = 0.0
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id
if company_obj:
    smmlv_from_company = company_obj.smmlv_value 
    temp_smmlv = 0.0
    try: 
        temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0
# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : 
            currency_rounding = test_float
            precision_rounding = test_float
    except (ValueError, TypeError): pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALUD_EMP_APR amount ---
result = 0.0 
# result_qty no se necesita aquí, la cantidad es 1 para esta deducción

# La condición ya aseguró que es Aprendiz Productiva y apoyo_sost > 0.
# La base es el valor del Apoyo de Sostenimiento (apoyo_sost del preámbulo).
base_deduccion = apoyo_sost

if not (abs(base_deduccion) < precision_rounding): # Si base_deduccion > 0
    # Porcentaje de aporte a salud para aprendiz productivo (usualmente 0% a cargo del aprendiz,
    # la empresa asume el 12.5% sobre 1 SMMLV, pero la DIAN requiere reportar el 4% del empleado si se deduce algo).
    # La normativa indica que para aprendices en etapa productiva, la cotización a salud
    # es cubierta plenamente por la empresa sobre la base de 1 SMMLV.
    # Si esta regla 'SALUD_EMP_APR' representa una deducción REAL al aprendiz, verifica la base legal.
    # Asumiendo que el 4% SÍ se deduce del apoyo de sostenimiento del aprendiz:
    percentage_deduction = 0.04 # 4%
    monto_calculado = base_deduccion * percentage_deduction

    if not (abs(monto_calculado) < precision_rounding):
        if payslip and payslip.currency_id:
            result = payslip.currency_id.round(monto_calculado)
        else:
            result = round(monto_calculado, 2) 
    else:
        result = 0.0
else:
    result = 0.0

# El resultado debe ser NEGATIVO para una deducción
result = -abs(result)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="True"/> <!-- Debe aparecer en la colilla -->
            <field name="type_concept">deduction</field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="deduction_category">health</field> <!-- Código DIAN para Salud -->
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field> <!-- Reportar % fijo -->
            <field name="edi_percent_fix">4.0</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                 <![CDATA[
## Partner es la EPS asignada en el contrato
# Acceso directo asumiendo que los campos existen.
# Si contract, eps_id o partner_id no existen, Odoo generará un AttributeError.
result = None
if contract and contract.eps_id and contract.eps_id.partner_id:
    result = contract.eps_id.partner_id.id
                 ]]>
             </field>
        </record>

        <!-- ============================================= -->
        <!-- REGLA: Deducción Pensión Empleado (Reg/Int) -->
        <!-- Código: PENSION_EMP -->
        <!-- ============================================= -->
        <record id="hr_rule_deduccion_pension_empleado" model="hr.salary.rule">
            <field name="name">Deducción Pensión Empleado (4%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">111</field> <!-- Secuencia después de Salud Emp -->
            <field name="code">PENSION_EMP</field>
            <field name="category_id" ref="hr_payroll.DED"/> <!-- Categoría Deducción -->
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_apprentice_lectiva = False # No relevante para esta regla, pero parte del preámbulo estándar
is_apprentice_productiva = False # No relevante para esta regla
is_any_apprentice = False

if contract: # Asumimos que 'contract' existe
    try: # Para contract.integral_salary
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass # is_integral permanece False

    try: # Para contract.type_worker_id.code
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': 
                is_apprentice_lectiva = True; is_any_apprentice = True
            elif worker_type_code_dian == '19': 
                is_apprentice_productiva = True; is_any_apprentice = True
    except AttributeError:
        pass # variables de aprendiz permanecen False
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) 

# --- Common helper variables ---
precision_rounding = 0.01 # Default para comparaciones > 0
try: 
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            precision_rounding = temp_float_rounding 
            # currency_rounding no se usa en esta condición específica, solo precision_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PENSION_EMP condition ---
result = False
pension_fund_exists_cond = False # Variable local para la condición
try:
    if contract and contract.pension_id: 
        pension_fund_exists_cond = True
except AttributeError:
    pass 

if pension_fund_exists_cond:
    if (is_regular or is_integral) and not (abs(ibc) < precision_rounding): # Reemplazo de float_is_zero
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# Preámbulo mínimo si necesitas precision_rounding o currency_rounding para el redondeo manual
precision_rounding = 0.01 
currency_rounding = 0.01 # O la lógica para obtenerlo de payslip.currency_id
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        # ... (lógica para obtener currency_rounding y precision_rounding) ...
        pass 
except: pass

base_para_deduccion = categories.get('CALCULO', 0.0) # Obtiene el IBC final
result = 0.0

if not (abs(base_para_deduccion) < precision_rounding):
    monto_calculado = base_para_deduccion * 0.04 # 4% para salud empleado
    # ... (tu lógica de redondeo manual para result, si es necesaria) ...
    # Ejemplo simple de redondeo manual:
    num_decimals = 2 # Para COP, usualmente 0 si es al peso, o 2 si manejas centavos
    if currency_rounding == 1.0: num_decimals = 0 
    
    if num_decimals >= 0:
        factor = 10 ** num_decimals
        result = float(int(monto_calculado * factor + (0.5 if monto_calculado >=0 else -0.5))) / factor
    else: 
        result = monto_calculado # O redondeo a decenas/centenas si aplica

result = abs(result)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="True"/> <!-- Debe aparecer en la colilla -->
            <field name="type_concept">deduction</field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="deduction_category">pension_fund</field> <!-- Código DIAN para Pensión -->
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field> <!-- Reportar % fijo -->
            <field name="edi_percent_fix">4.0</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                 <![CDATA[
# ======================================================
# Preámbulo Mínimo para co_partner_python_compute
# ======================================================
result = None 
try:
    if contract and contract.eps_id and contract.pension_id.partner_id:
        result = contract.pension_id.partner_id.id
except AttributeError:
    result = None
                 ]]>
             </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: FSP - SOLIDARIDAD (Variable %) (FSP_SOL) - AJUSTADA                -->
        <!-- =========================================================== -->
        <record id="hr_rule_fsp_solidaridad" model="hr.salary.rule">
            <field name="name">Fondo Solidaridad Pensional (Variable %)</field> <!-- Nombre actualizado -->
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">112</field> <!-- Ajustada secuencia para estar después de PENSION_EMP -->
            <field name="code">FSP_SOL</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_any_apprentice = False # FSP no aplica a aprendices

if contract: 
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12' or worker_type_code_dian == '19': 
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) # 'IBC' es el CÓDIGO de la CATEGORÍA donde está el resultado de tu regla IBC

# --- Company specific values ---
smmlv = 0.0
precision_rounding = 0.01 # Para comparaciones
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0 
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for FSP_SOL condition ---
result = False
# FSP aplica a Regulares e Integrales (no aprendices)
# si su IBC es >= 4 SMMLV y tienen fondo de pensión.

fsp_threshold = 0.0
condition_smmlv_positive = not (abs(smmlv) < precision_rounding) # Verifica que smmlv > 0
if condition_smmlv_positive:
    fsp_threshold = 4.0 * smmlv

pension_fund_assigned_cond = False
try:
    if contract and contract.pension_id:
        pension_fund_assigned_cond = True
except AttributeError:
    pass

condition_ibc_not_zero = not (abs(ibc) < precision_rounding)

if pension_fund_assigned_cond and condition_smmlv_positive and condition_ibc_not_zero:
    if not is_any_apprentice: # Aplica si NO es Aprendiz
        # Usar (fsp_threshold - precision_rounding) para comparación segura de flotantes si ibc debe ser estrictamente >=
        # o simplemente ibc >= fsp_threshold si la igualdad exacta es válida.
        # Dado que la ley es >= 4 SMMLV, ibc >= fsp_threshold es correcto si fsp_threshold ya es 4*smmlv.
        # Para ser más seguro con flotantes: ibc > (fsp_threshold - precision_rounding)
        if ibc >= (fsp_threshold - precision_rounding):
            result = True
# NOTA: No aplica a Aprendices ni si IBC es menor a 4 SMMLV.
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
## ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) # 'IBC' es el CÓDIGO de tu CATEGORÍA para el IBC

# --- Company specific values ---
smmlv = 0.0
precision_rounding = 0.01 
company_obj_amount = None
if contract and contract.company_id:
    company_obj_amount = contract.company_id

if company_obj_amount:
    try:
        smmlv_from_company = company_obj_amount.smmlv_value
        if smmlv_from_company is not None:
            temp_smmlv = float(smmlv_from_company)
            if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for FSP_SOL amount ---
result = 0.0 
base_deduccion = ibc
percentage_fsp = 0.0

# Solo calcular si smmlv es positivo y base_deduccion es positiva
# La condición de la regla ya verificó ibc >= 4 smmlv
condition_smmlv_positive_amount = not (abs(smmlv) < precision_rounding)
condition_base_deduccion_positive = not (abs(base_deduccion) < precision_rounding)

if condition_smmlv_positive_amount and condition_base_deduccion_positive:
    ibc_smmlv_ratio = base_deduccion / smmlv 

    # Comparaciones seguras con flotantes, ej. (20.0 - precision_rounding)
    if ibc_smmlv_ratio >= (20.0 - precision_rounding): percentage_fsp = 0.020 
    elif ibc_smmlv_ratio >= (19.0 - precision_rounding): percentage_fsp = 0.018
    elif ibc_smmlv_ratio >= (18.0 - precision_rounding): percentage_fsp = 0.016
    elif ibc_smmlv_ratio >= (17.0 - precision_rounding): percentage_fsp = 0.014
    elif ibc_smmlv_ratio >= (16.0 - precision_rounding): percentage_fsp = 0.012
    # La condición de la regla (ibc >= 4SMMLV) ya cubre el límite inferior para el 1%
    elif ibc_smmlv_ratio >= (4.0 - precision_rounding): percentage_fsp = 0.010

if condition_base_deduccion_positive and percentage_fsp > 0:
    monto_calculado = base_deduccion * percentage_fsp

    # Redondeo PILA a la centena superior (sin math.ceil)
    if not (abs(monto_calculado) < precision_rounding):
        _value_to_round_up = monto_calculado
        _multiple = 100.0
        if _value_to_round_up > 0:
            if abs(_value_to_round_up % _multiple) < precision_rounding or abs(_value_to_round_up % _multiple - _multiple) < precision_rounding :
                 result = _value_to_round_up
            else:
                 result = (float(int(_value_to_round_up / _multiple)) + 1.0) * _multiple
        # else: result permanece 0.0
    # else: result permanece 0.0
else:
    result = 0.0

result =abs(result)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="True"/> <!-- Debe aparecer en la colilla -->
            <field name="type_concept">deduction</field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="deduction_category">pension_security_fund</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">code</field> <!-- Reportar % aplicado -->
            <field name="edi_percent_python_compute">
                <![CDATA[
# ======================================================
# Preámbulo Mínimo para edi_percent_python_compute
# ======================================================
ibc = categories.get('IBC', 0.0) # 'IBC' es el CÓDIGO de tu CATEGORÍA para el IBC
smmlv = 0.0
precision_rounding = 0.01
company_obj_edi = None
if contract and contract.company_id:
    company_obj_edi = contract.company_id
if company_obj_edi:
    try:
        smmlv_from_company = company_obj_edi.smmlv_value
        if smmlv_from_company is not None:
            temp_smmlv = float(smmlv_from_company)
            if temp_smmlv > 0: smmlv = temp_smmlv
    except: pass

result = 0.0 # Porcentaje FSP
# Solo calcular si smmlv es positivo, ibc es positivo y ibc es al menos 4 SMMLV
condition_smmlv_positive_edi = not (abs(smmlv) < precision_rounding)
condition_ibc_not_zero_edi = not (abs(ibc) < precision_rounding)

if condition_smmlv_positive_edi and condition_ibc_not_zero_edi and ibc >= (4 * smmlv - precision_rounding):
    ibc_smmlv_ratio = ibc / smmlv
    if ibc_smmlv_ratio >= (20.0 - precision_rounding): result = 2.0
    elif ibc_smmlv_ratio >= (19.0 - precision_rounding): result = 1.8
    elif ibc_smmlv_ratio >= (18.0 - precision_rounding): result = 1.6
    elif ibc_smmlv_ratio >= (17.0 - precision_rounding): result = 1.4
    elif ibc_smmlv_ratio >= (16.0 - precision_rounding): result = 1.2
    else: result = 1.0 # Para el rango de 4 a <16 SMMLV
                ]]>
            </field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                 <![CDATA[
# ======================================================
# Preámbulo Mínimo para co_partner_python_compute
# ======================================================
result = None 
try:
    if contract and contract.pension_id and contract.pension_id.partner_id:
        result = contract.pension_id.partner_id.id
except AttributeError:
    result = None 
                 ]]>
             </field>
        </record>

        <!-- =========================================================== -->
        <!--   REGLA: FSP - SUBSISTENCIA (Adicional) (FSP_SUB)           -->
        <!-- =========================================================== -->
        <record id="hr_rule_fsp_subsistencia" model="hr.salary.rule">
            <field name="name">Fondo Solidaridad Pensional - Subsistencia</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">113</field>
            <field name="code">FSP_SUB</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_any_apprentice = False 

if contract: 
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12' or worker_type_code_dian == '19': 
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) # 'IBC' es el CÓDIGO de la CATEGORÍA donde está el resultado de tu regla IBC

# --- Company specific values ---
smmlv = 0.0
precision_rounding = 0.01 
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0 
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for FSP_SUB condition ---
result = False
# FSP-Subsistencia aplica a Regulares e Integrales (no aprendices)
# si su IBC es >= 16 SMMLV y tienen fondo de pensión.

fsp_sub_threshold = 0.0
condition_smmlv_positive = not (abs(smmlv) < precision_rounding) # Verifica que smmlv > 0
if condition_smmlv_positive:
    fsp_sub_threshold = 16.0 * smmlv

pension_fund_assigned_cond = False
try:
    if contract and contract.pension_id:
        pension_fund_assigned_cond = True
except AttributeError:
    pass

condition_ibc_not_zero = not (abs(ibc) < precision_rounding)

if pension_fund_assigned_cond and condition_smmlv_positive and condition_ibc_not_zero:
    if not is_any_apprentice: 
        # Comparación segura con flotantes
        if ibc >= (fsp_sub_threshold - precision_rounding):
            result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
ibc = categories.get('IBC', 0.0) # 'IBC' es el CÓDIGO de tu CATEGORÍA para el IBC
smmlv = 0.0
precision_rounding = 0.01 
company_obj_amount = None
if contract and contract.company_id:
    company_obj_amount = contract.company_id

if company_obj_amount:
    try:
        smmlv_from_company = company_obj_amount.smmlv_value
        if smmlv_from_company is not None:
            temp_smmlv = float(smmlv_from_company)
            if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for FSP_SUB amount ---
result = 0.0
base_deduccion = ibc
additional_percentage = 0.0

condition_smmlv_positive_amount = not (abs(smmlv) < precision_rounding)
condition_base_deduccion_positive = not (abs(base_deduccion) < precision_rounding)

if condition_smmlv_positive_amount and condition_base_deduccion_positive:
    ibc_smmlv_ratio = base_deduccion / smmlv

    # Porcentajes para la subcuenta de SUBSISTENCIA
    if ibc_smmlv_ratio >= (20.0 - precision_rounding): additional_percentage = 0.010 # 1.0%
    elif ibc_smmlv_ratio >= (19.0 - precision_rounding): additional_percentage = 0.008 # 0.8%
    elif ibc_smmlv_ratio >= (18.0 - precision_rounding): additional_percentage = 0.006 # 0.6%
    elif ibc_smmlv_ratio >= (17.0 - precision_rounding): additional_percentage = 0.004 # 0.4%
    # La condición de la regla ya asegura ibc >= 16 SMMLV para que esta se active
    elif ibc_smmlv_ratio >= (16.0 - precision_rounding): additional_percentage = 0.002 # 0.2%

if condition_base_deduccion_positive and additional_percentage > 0:
    monto_calculado = base_deduccion * additional_percentage

    # Redondeo PILA a la centena superior (sin math.ceil)
    if not (abs(monto_calculado) < precision_rounding):
        _value_to_round_up = monto_calculado
        _multiple = 100.0
        if _value_to_round_up > 0:
            if abs(_value_to_round_up % _multiple) < precision_rounding or abs(_value_to_round_up % _multiple - _multiple) < precision_rounding :
                 result = _value_to_round_up
            else:
                 result = (float(int(_value_to_round_up / _multiple)) + 1.0) * _multiple
        # else: result permanece 0.0
    # else: result permanece 0.0
else:
    result = 0.0

result = abs(result) # Asegurar que es negativo
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">pension_security_fund_subsistence</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">code</field>
            <field name="edi_percent_python_compute">
                <![CDATA[
# ======================================================
# Preámbulo Mínimo para edi_percent_python_compute
# ======================================================
ibc = categories.get('IBC', 0.0) # 'IBC' es el CÓDIGO de tu CATEGORÍA para el IBC
smmlv = 0.0
precision_rounding = 0.01
company_obj_edi = None
if contract and contract.company_id:
    company_obj_edi = contract.company_id
if company_obj_edi:
    try:
        smmlv_from_company = company_obj_edi.smmlv_value
        if smmlv_from_company is not None:
            temp_smmlv = float(smmlv_from_company)
            if temp_smmlv > 0: smmlv = temp_smmlv
    except: pass

result = 0.0 # Porcentaje FSP Subsistencia
condition_smmlv_positive_edi = not (abs(smmlv) < precision_rounding)
condition_ibc_not_zero_edi = not (abs(ibc) < precision_rounding)

# La condición de la regla principal ya asegura ibc >= 16 SMMLV
if condition_smmlv_positive_edi and condition_ibc_not_zero_edi and ibc >= (16 * smmlv - precision_rounding):
    ibc_smmlv_ratio = ibc / smmlv
    if ibc_smmlv_ratio >= (20.0 - precision_rounding): result = 1.0 # 1.0%
    elif ibc_smmlv_ratio >= (19.0 - precision_rounding): result = 0.8 # 0.8%
    elif ibc_smmlv_ratio >= (18.0 - precision_rounding): result = 0.6 # 0.6%
    elif ibc_smmlv_ratio >= (17.0 - precision_rounding): result = 0.4 # 0.4%
    else: result = 0.2 # Para el rango de 16 a <17 SMMLV (0.2%)
                ]]>
            </field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Preámbulo Mínimo para co_partner_python_compute
# ======================================================
result = None 
try:
    if contract and contract.pension_id and contract.pension_id.partner_id:
        result = contract.pension_id.partner_id.id
except AttributeError:
    result = None 
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN PENSIÓN VOLUNTARIA (PENSION_VOL - Recurrente) -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_pension_voluntaria" model="hr.salary.rule">
            <field name="name">Deducción Pensión Voluntaria</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">114</field>
            <field name="code">PENSION_VOL</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PENSION_VOL condition ---
result = False
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id), # Busca por regla PENSION_VOL
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PENSION_VOL amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Usar amount como base si no hay código
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)
        
        # Standard currency rounding for the deduction amount
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
        
        # Result must be negative for a deduction
        # abs() es una función built-in de Python y debería estar disponible
        result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">voluntary_pension</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
from odoo.tools import float_is_zero, float_compare
# import math
# import logging
# _logger = logging.getLogger(__name__)

# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if hasattr(contract, 'integral_salary') and contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if hasattr(company_obj, 'smmlv_value') and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if hasattr(company_obj, 'uvt_value') and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if hasattr(company_obj, 'ley_1607'):
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PENSION_VOL co_partner ---
partner_id = None
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem:
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item and recurring_item.recurring_item_type_id and \
       hasattr(recurring_item.recurring_item_type_id, 'partner_id') and \
       recurring_item.recurring_item_type_id.partner_id:
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: RETENCIÓN EN LA FUENTE (RETEFUENTE) - ¡¡REVISAR!! -->
        <!-- =========================================================== -->
        <record id="hr_rule_retencion_fuente" model="hr.salary.rule">
            <field name="name">Retención en la Fuente (Proc. 1)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">150</field>
            <field name="code">RETEFUENTE</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: 
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': 
                is_apprentice_lectiva = True; is_any_apprentice = True
            elif worker_type_code_dian == '19': 
                is_apprentice_productiva = True; is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Company specific values (solo uvt_value y precision_rounding son necesarios aquí) ---
uvt_value = 0.0
precision_rounding = 0.01 # Para la comparación uvt_value > 0
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        # Acceso directo, si el campo no existe, dará AttributeError
        uvt_from_company = company_obj_cond.uvt_value 
        if uvt_from_company is not None: 
             temp_uvt = float(uvt_from_company)
             if temp_uvt > 0: uvt_value = temp_uvt
    except (AttributeError, ValueError, TypeError):
        uvt_value = 0.0
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for RETEFUENTE condition ---
result = False
# Aplica si NO es aprendiz, hay contrato y UVT es válida.
# El cálculo real (en el método _calculate_retefuente) determinará si hay base gravable.
if contract and not is_any_apprentice and not (abs(uvt_value) < precision_rounding): # uvt_value > 0
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Preámbulo Mínimo para RETEFUENTE (Ultra-Restrictive Env v3)
# ======================================================
result = 0.0 # VALOR FINAL DE LA RETENCIÓN (NEGATIVO)
precision_rounding = 0.01
currency_rounding = 0.01 

# --- Obtener SMMLV y UVT (Acceso directo y try-except) ---
smmlv = 0.0
uvt_value = 0.0
if contract and contract.company_id:
    company_obj = contract.company_id
    try:
        smmlv_val = company_obj.smmlv_value
        if smmlv_val is not None:
            temp_s = float(smmlv_val)
            if temp_s > 0: smmlv = temp_s
    except (AttributeError, ValueError, TypeError): pass

    try:
        uvt_val = company_obj.uvt_value
        if uvt_val is not None:
            temp_u = float(uvt_val)
            if temp_u > 0: uvt_value = temp_u
    except (AttributeError, ValueError, TypeError): pass

try: 
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        temp_cr = float(payslip.currency_id.rounding)
        if 0.0 <= temp_cr <= 1.0 : currency_rounding = temp_cr
except (AttributeError, ValueError, TypeError): pass
precision_rounding = currency_rounding if currency_rounding != 0 else 0.01

# --- Condición de Salida Temprana (si UVT no es válida) ---
if abs(uvt_value) < precision_rounding: 
    result = 0.0 
else:
    # --- PASO 1: Obtener Ingresos Totales Gravables del Mes ---
    # Usando TU SINTAXIS FUNCIONAL con result_rules
    # 'TOTAL_RETENCION' es el CÓDIGO de tu regla "Total Ingresos Retención"
    codigo_regla_total_ingresos = 'TOTAL_RETENCION' # CONFIRMADO POR TI
    ingresos_gravables_mes = 0.0
    if codigo_regla_total_ingresos in result_rules: # Verificar si la regla existe en el dict
        try:
            ingresos_gravables_mes = float(result_rules[codigo_regla_total_ingresos].get('total', 0.0) or 0.0)
        except (ValueError, TypeError, KeyError): # KeyError por si 'total' no existe
            ingresos_gravables_mes = 0.0

    if abs(ingresos_gravables_mes) < precision_rounding:
        result = 0.0 
    else:
        # --- PASO 2: Calcular INCRNGO (Aportes Obligatorios del Empleado) ---
        # Usando TU SINTAXIS FUNCIONAL con result_rules
        cod_regla_salud_emp = 'SALUD_EMP'         # ¡PERSONALIZA SI ES NECESARIO!
        cod_regla_pension_emp = 'PENSION_EMP'     # ¡PERSONALIZA SI ES NECESARIO!
        cod_regla_fsp_sol = 'FSP_SOL'             # ¡PERSONALIZA SI ES NECESARIO!
        cod_regla_fsp_sub = 'FSP_SUB'             # ¡PERSONALIZA SI ES NECESARIO!

        aporte_salud_empleado = 0.0
        if cod_regla_salud_emp in result_rules:
            try:
                aporte_salud_empleado = abs(float(result_rules[cod_regla_salud_emp].get('total', 0.0) or 0.0))
            except (ValueError, TypeError, KeyError): pass
        
        aporte_pension_empleado = 0.0
        if cod_regla_pension_emp in result_rules:
            try:
                aporte_pension_empleado = abs(float(result_rules[cod_regla_pension_emp].get('total', 0.0) or 0.0))
            except (ValueError, TypeError, KeyError): pass

        aporte_fsp_empleado = 0.0
        if cod_regla_fsp_sol in result_rules:
            try:
                aporte_fsp_empleado += abs(float(result_rules[cod_regla_fsp_sol].get('total', 0.0) or 0.0))
            except (ValueError, TypeError, KeyError): pass
        if cod_regla_fsp_sub in result_rules:
            try:
                aporte_fsp_empleado += abs(float(result_rules[cod_regla_fsp_sub].get('total', 0.0) or 0.0))
            except (ValueError, TypeError, KeyError): pass
            
        incrngo = aporte_salud_empleado + aporte_pension_empleado + aporte_fsp_empleado

        # --- PASO 3: Calcular Deducciones Adicionales ---
        # ¡DEBES IMPLEMENTAR ESTO! Obtener de inputs o campos, aplicar topes UVT.
        deduccion_intereses_vivienda = 0.0 
        deduccion_medicina_prepagada = 0.0 
        deduccion_dependientes = 0.0       
        deducciones_legales_adicionales = deduccion_intereses_vivienda + deduccion_medicina_prepagada + deduccion_dependientes

        # --- PASO 4: Calcular Renta Exenta (25%) y aplicar Límite Global 40% ---
        ingreso_base_para_limites_y_exentas = max(0.0, ingresos_gravables_mes - incrngo) 
        base_para_25_exento = max(0.0, ingreso_base_para_limites_y_exentas - deducciones_legales_adicionales)
        renta_exenta_25_calculada = base_para_25_exento * 0.25
        
        tope_renta_exenta_uvt_mensual = 790.0 / 12.0 
        tope_renta_exenta_pesos = tope_renta_exenta_uvt_mensual * uvt_value
        renta_exenta_25_final = min(renta_exenta_25_calculada, tope_renta_exenta_pesos)
        
        limite_del_40_porciento = ingreso_base_para_limites_y_exentas * 0.40
        limite_1340_uvt_anual_pesos = 1340.0 * uvt_value 
        limite_1340_uvt_mensual_pesos_proporcional = limite_1340_uvt_anual_pesos / 12.0
        limite_global_aplicable = min(limite_del_40_porciento, limite_1340_uvt_mensual_pesos_proporcional)

        total_deducciones_y_exentas_para_limitar = deducciones_legales_adicionales + renta_exenta_25_final
        deducciones_y_exentas_efectivas = min(total_deducciones_y_exentas_para_limitar, limite_global_aplicable)
        
        # --- PASO 5: Calcular Base Gravable en Pesos y UVT ---
        base_gravable_pesos = ingreso_base_para_limites_y_exentas - deducciones_y_exentas_efectivas
        base_gravable_pesos = max(0.0, base_gravable_pesos)
        
        base_gravable_uvt = 0.0
        if uvt_value > precision_rounding:
            base_gravable_uvt = base_gravable_pesos / uvt_value

        # --- PASO 6: Aplicar Tabla de Retención (Art. 383 ET) ---
        # ¡¡¡VERIFICA ESTA TABLA CON LA NORMATIVA VIGENTE PARA EL AÑO DE LA NÓMINA!!!
        retencion_uvt = 0.0
        # Usaremos comparaciones directas con un pequeño margen por si hay flotantes.
        # O puedes usar float_compare si está disponible y permitido (no está en tu lista de built-ins permitidos)
        # Por ahora, usaré comparaciones directas con un pequeño épsilon (precision_rounding) si es necesario.
        
        if base_gravable_uvt <= (95.0 + precision_rounding): retencion_uvt = 0.0
        elif base_gravable_uvt <= (150.0 + precision_rounding): retencion_uvt = (base_gravable_uvt - 95.0) * 0.19
        elif base_gravable_uvt <= (360.0 + precision_rounding): retencion_uvt = ((base_gravable_uvt - 150.0) * 0.28) + 10.0
        elif base_gravable_uvt <= (640.0 + precision_rounding): retencion_uvt = ((base_gravable_uvt - 360.0) * 0.33) + 69.0
        elif base_gravable_uvt <= (945.0 + precision_rounding): retencion_uvt = ((base_gravable_uvt - 640.0) * 0.35) + 162.0
        elif base_gravable_uvt <= (2300.0 + precision_rounding): retencion_uvt = ((base_gravable_uvt - 945.0) * 0.37) + 268.0
        else: retencion_uvt = ((base_gravable_uvt - 2300.0) * 0.39) + 770.0
        
        # --- PASO 7: Convertir Retención a Pesos y Redondear ---
        retencion_pesos_sin_redondear = retencion_uvt * uvt_value
        
        retencion_final_pesos = 0.0 # Inicializar
        if retencion_pesos_sin_redondear > precision_rounding:
            # Redondeo DIAN: Usualmente al múltiplo de 1000 más cercano, generalmente hacia abajo (truncar).
            # Implementación de truncar al 1000 inferior:
            retencion_final_pesos = float(int(retencion_pesos_sin_redondear / 1000.0)) * 1000.0
            result = retencion_final_pesos
        else:
            result = 0.0

# El resultado de la retención es una deducción, por lo tanto, debe ser negativo.
result = abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">withholding_source</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: DEDUCCIÓN APORTE AFC (AFC - Recurrente)         -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_afc" model="hr.salary.rule">
            <field name="name">Deducción Aporte AFC</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">151</field>
            <field name="code">AFC</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for AFC condition ---
result = False
# Consider adding employee type check if AFC is restricted (e.g., if not is_regular: result = False else: ...)
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for AFC amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)
        
        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
        
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">afc</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
from odoo.tools import float_is_zero, float_compare # Always useful for numeric comparisons
# import math # Only if you use math functions (ceil, etc.)
# import logging # Import logging if you need to log messages within the script
# _logger = logging.getLogger(__name__) # Initialize logger if logging is imported

# --- Environment objects (Automatically available) ---
# payslip: hr.payslip record for the current payslip
# employee: hr.employee record
# contract: hr.contract record
# categories: Dictionary with results of rules with lower sequence (e.g., categories.get('IBC', 0.0))
# inputs: Dictionary with amounts from payslip.input_line_ids (e.g., inputs.get('MANUAL_CODE', 0.0))
# worked_days: Dictionary with worked_days_line_ids (e.g., worked_days.get('ATT', None))
# rule: hr.salary.rule record of the current rule
# env: Odoo environment object (use payslip.env for safer access in sandbox)

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if hasattr(contract, 'integral_salary') and contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Example, uncomment if needed for this rule's logic
# apoyo_sost = categories.get('APOYO_SOST', 0.0) # Example, uncomment if needed

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if hasattr(company_obj, 'smmlv_value') and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if hasattr(company_obj, 'uvt_value') and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if hasattr(company_obj, 'ley_1607'): is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for AFC co_partner ---
partner_id = None
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem:
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item and recurring_item.recurring_item_type_id and \
       hasattr(recurring_item.recurring_item_type_id, 'partner_id') and \
       recurring_item.recurring_item_type_id.partner_id:
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

       <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN COOPERATIVA (COOPERATIVA - Recurrente)     -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_cooperativa" model="hr.salary.rule">
            <field name="name">Deducción Cooperativa</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">152</field>
            <field name="code">COOPERATIVA</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COOPERATIVA condition ---
result = False
# Consider adding employee type check if COOPERATIVA is restricted (e.g., if not is_regular: result = False else: ...)
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True               
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COOPERATIVA amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)
        
        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">cooperative</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for COOPERATIVA co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN EMBARGO FISCAL (EMBARGO_FISCAL - Recurrente) -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_embargo_fiscal" model="hr.salary.rule">
            <field name="name">Deducción Embargo Fiscal</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">153</field>
            <field name="code">EMBARGO_FISCAL</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for EMBARGO_FISCAL condition ---
result = False
# Consider adding employee type check if EMBARGO_FISCAL is restricted (e.g., if not is_regular: result = False else: ...)
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <!-- CÁLCULO REQUIERE VALIDACIÓN DE LÍMITES LEGALES DE EMBARGABILIDAD -->
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for EMBARGO_FISCAL amount ---
# ############################################################
# ## ¡¡¡ATENCIÓN: CÁLCULO DE EMBARGO SIMPLIFICADO!!!       ##
# ## Esta lógica toma el valor del item recurrente PERO    ##
# ## NO aplica límites legales de embargabilidad (ej: %    ##
# ## sobre excedente del SMMLV, reglas especiales para    ##
# ## alimentos/cooperativas). ¡¡VALIDAR E IMPLEMENTAR!!   ##
# ############################################################
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # --- ¡¡AQUÍ DEBERÍA IR LA VALIDACIÓN DE LÍMITES LEGALES!! ---
        # Ejemplo conceptual (NO COMPLETO):
        # smmlv_val = smmlv # from preamble
        # salary_base_for_garnishment = categories.get('NET', 0.0) # O la base legal correcta
        # Si tienes un método en hr.payslip para calcular el límite:
        # legal_limit = 0.0
        # if payslip:
        #     try:
        #         legal_limit = payslip._calculate_garnishment_limit(
        #             salary_base_for_garnishment,
        #             smmlv_val,
        #             recurring_item.embargo_type if recurring_item.embargo_type else None # Asume campo 'embargo_type' en recurring_item
        #         )
        #     except Exception:
        #         legal_limit = amount_to_deduct # Fallback si hay error en el cálculo del límite
        # amount_to_deduct = min(amount_to_deduct, legal_limit)
        # --- Fin Ejemplo Conceptual ---
        
        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0

# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">tax_lien</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for EMBARGO_FISCAL co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: DEDUCCIÓN LIBRANZA (LIBRANZA - Recurrente)      -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_libranza" model="hr.salary.rule">
            <field name="name">Deducción Libranza</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">154</field>
            <field name="code">LIBRANZA</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule

# --- Employee Type Determination (Consistente con tus otras reglas v3) ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False
is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    try:
        if contract.integral_salary: is_integral = True
    except Exception: pass # CAMBIADO: De AttributeError a Exception
    try:
        if contract.type_worker_id and contract.type_worker_id.code:
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': is_apprentice_lectiva = True; is_any_apprentice = True
            elif worker_type_code_dian == '19': is_apprentice_productiva = True; is_any_apprentice = True
    except Exception: pass # CAMBIADO: De AttributeError a Exception
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Common helper variables ---
precision_rounding = 0.01 # Default
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding = payslip.currency_id.rounding
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : precision_rounding = test_float
# CAMBIADO: (AttributeError, ValueError, TypeError) a solo Exception 
# (o (Exception, ValueError, TypeError) si quieres ser específico y sabes que ValueError/TypeError sí están definidos por nombre)
# Usar Exception solo es más seguro si hay dudas.
except Exception: pass 
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LIBRANZA condition (usando inputs) ---
result = False
libranza_input_obj = None
input_amount_numeric = 0.0

try:
    libranza_input_obj = inputs.LIBRANZA # Acceso por atributo
except Exception: # CAMBIADO: De AttributeError a Exception
    try:
        libranza_input_obj = inputs.get('LIBRANZA') # Acceso por get item
    # CAMBIADO: (AttributeError, KeyError) a solo Exception
    except Exception: 
        pass # libranza_input_obj permanece None

if libranza_input_obj:
    try:
        input_amount_numeric = float(libranza_input_obj.amount or 0.0)
    # CAMBIADO: (AttributeError, ValueError, TypeError) a solo Exception
    except Exception:
        input_amount_numeric = 0.0
    
    if input_amount_numeric > precision_rounding: # Se activa si hay un monto positivo en la entrada
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# (Como lo teníamos en la respuesta anterior, con los except Exception)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule

# --- Common helper variables ---
currency_rounding = 0.01 # Default
precision_rounding = 0.01 # Default
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding = payslip.currency_id.rounding
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 :
            currency_rounding = test_float
            precision_rounding = test_float
except Exception: pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LIBRANZA amount (usando inputs) ---
result = 0.0
libranza_input_amount = 0.0
libranza_input_obj = None

try:
    libranza_input_obj = inputs.LIBRANZA
except Exception: 
    try:
        libranza_input_obj = inputs.get('LIBRANZA')
    except Exception: 
        pass

if libranza_input_obj:
    try:
        libranza_input_amount = float(libranza_input_obj.amount or 0.0)
    except Exception:
        libranza_input_amount = 0.0

amount_to_deduct_unrounded = libranza_input_amount # Guardamos el valor antes de redondear

# --- Lógica de redondeo (tomada de tu ejemplo) ---
num_decimals = 2 
if currency_rounding == 1.0: num_decimals = 0
# ... (más lógica para num_decimals si es necesario) ...

rounded_amount_to_deduct = 0.0
if num_decimals >= 0:
    factor = 10 ** num_decimals
    rounded_amount_to_deduct = float(int(amount_to_deduct_unrounded * factor + (0.5 if amount_to_deduct_unrounded >=0 else -0.5) + 1e-9)) / factor
else: 
    factor = 10 ** abs(num_decimals)
    rounded_amount_to_deduct = float(int(amount_to_deduct_unrounded / factor + (0.5 if amount_to_deduct_unrounded >=0 else -0.5) + 1e-9)) * factor
# --- Fin de la lógica de redondeo ---

# Asignar el valor de la deducción (que debe ser positivo)
if not (abs(rounded_amount_to_deduct) < precision_rounding):
    result = rounded_amount_to_deduct
else:
    result = 0.0
            
# NO se necesita result = -abs(result) aquí. 
# El 'result' de esta regla de deducción debe ser POSITIVO.
# La regla NET se encargará de restarlo.
# Si rounded_amount_to_deduct es negativo por alguna razón (no debería serlo para una libranza),
# abs() lo haría positivo, lo cual es correcto para la magnitud de la deducción.
result = abs(result) # Asegura que sea la magnitud positiva de la deducción.
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">libranzas</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for LIBRANZA co_partner ---
result = None # ID del partner
libranza_input_obj = None

try:
    libranza_input_obj = inputs.LIBRANZA # Intenta acceder como atributo
except Exception: # CAMBIADO: De AttributeError a Exception
    try:
        libranza_input_obj = inputs.get('LIBRANZA') # Intenta acceder como item de diccionario
    except Exception: # CAMBIADO: De (AttributeError, KeyError) a Exception
        pass # libranza_input_obj permanece None

if libranza_input_obj:
    try:
        # Esto ASUME que tu objeto hr.payslip.input HA SIDO PERSONALIZADO
        # para tener un campo 'partner_id' (Many2one a res.partner) y que este
        # se popula con el Tercero (BANCOLOMBIA S.A.) cuando se crea el input.
        # El hr.payslip.input estándar NO tiene este campo.
        if libranza_input_obj.partner_id: # Asume que input tiene un campo partner_id (Many2one)
            result = libranza_input_obj.partner_id.id
    except Exception: # CAMBIADO: De AttributeError a Exception
        # Si el input no tiene un campo 'partner_id' (porque AttributeError ocurriría
        # al intentar acceder a libranza_input_obj.partner_id si el atributo no existe),
        # o si partner_id es None y se intenta acceder a .id (aunque el 'if' previo lo previene),
        # result permanece None.
        pass
                ]]>
            </field>
        </record>

       <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN PLAN COMPLEMENTARIO (PLAN_COMP - Recurrente) -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_plan_comp" model="hr.salary.rule">
            <field name="name">Deducción Plan Complementario Salud</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">155</field>
            <field name="code">PLAN_COMP</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PLAN_COMP condition ---
result = False
# Consider adding employee type check if PLAN_COMP is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PLAN_COMP amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">complementary_plans</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PLAN_COMP co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id

                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--     REGLA: DEDUCCIÓN EDUCACIÓN (EDUCACION - Recurrente)     -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_educacion" model="hr.salary.rule">
            <field name="name">Deducción Educación</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">156</field>
            <field name="code">EDUCACION</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for EDUCACION condition ---
result = False
# Consider adding employee type check if EDUCACION is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for EDUCACION amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">education</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for EDUCACION co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--        REGLA: DEDUCCIÓN DEUDA (DEUDA - Recurrente)          -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_deuda" model="hr.salary.rule">
            <field name="name">Deducción Deuda</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">157</field>
            <field name="code">DEUDA</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for DEUDA condition ---
result = False
# Consider adding employee type check if DEUDA is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for DEUDA amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">debt</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for DEUDA co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--   REGLA: DEDUCCIÓN SINDICATO (SINDICATO - Recurrente)       -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_sindicato" model="hr.salary.rule">
            <field name="name">Deducción Cuota Sindical</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">158</field>
            <field name="code">SINDICATO</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SINDICATO condition ---
result = False
# Consider adding employee type check if SINDICATO is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SINDICATO amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                # Fallback a SALARIO o wage si no hay código base
                # 'contract' and 'categories' are available from the preamble
                base_value = categories.get('SALARIO', contract.wage if contract and contract.wage is not None else 0.0)
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">trade_unions</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SINDICATO co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN SANCIÓN PÚBLICA (SANCION_PUB - Recurrente) -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_sancion_pub" model="hr.salary.rule">
            <field name="name">Deducción Sanción Pública</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">159</field>
            <field name="code">SANCION_PUB</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SANCION_PUB condition ---
result = False
# Consider adding employee type check if SANCION_PUB is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
             <!-- CÁLCULO PUEDE REQUERIR VALIDACIÓN DE LÍMITES LEGALES -->
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SANCION_PUB amount ---
# (Lógica estándar para item recurrente - ¡Validar límites legales de deducción por sanción!)
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # --- ¡¡AQUÍ VALIDAR LÍMITES LEGALES SI APLICA!! ---
        # Las sanciones públicas pueden tener límites específicos.
        # Por ejemplo, no pueden afectar el mínimo vital del trabajador.
        # Deberías tener una lógica para calcular este límite.
        # Ejemplo conceptual (NO COMPLETO):
        # net_salary = categories.get('NET', 0.0) # O la base legal correcta
        # minimum_vital = smmlv # O el valor que corresponda
        # if net_salary - amount_to_deduct < minimum_vital:
        #    amount_to_deduct = net_salary - minimum_vital
        #    if amount_to_deduct < 0: amount_to_deduct = 0.0
        # --- Fin Ejemplo Conceptual ---

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">sanctions_public</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SANCION_PUB co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN SANCIÓN PRIVADA (SANCION_PRIV - Recurrente) -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_sancion_priv" model="hr.salary.rule">
            <field name="name">Deducción Sanción Privada</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">160</field>
            <field name="code">SANCION_PRIV</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SANCION_PRIV condition ---
result = False
# Consider adding employee type check if SANCION_PRIV is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <!-- CÁLCULO PUEDE REQUERIR VALIDACIÓN DE LÍMITES LEGALES/REGLAMENTO -->
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SANCION_PRIV amount ---
# (Lógica estándar para item recurrente - ¡Validar límites legales/reglamento interno!)
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # --- ¡¡AQUÍ VALIDAR LÍMITES LEGALES/REGLAMENTO INTERNO!! ---
        # Las sanciones privadas (disciplinarias) también tienen límites.
        # Generalmente, no pueden exceder la quinta parte del salario de un día por la primera vez,
        # o la quinta parte del salario de varios días si es reincidencia, y deben seguir
        # el debido proceso establecido en el reglamento interno de trabajo.
        # Ejemplo conceptual (NO COMPLETO):
        # daily_salary = categories.get('SALARIO_DIARIO', 0.0) # Necesitarías una regla para esto
        # if daily_salary > 0:
        #     max_sanction_one_day = daily_salary / 5.0
        #     # Aquí necesitarías lógica para determinar si es la primera vez o reincidencia
        #     # y si la sanción es por varios días.
        #     # Este es un ejemplo muy simplificado:
        #     legal_limit = max_sanction_one_day
        #     amount_to_deduct = min(amount_to_deduct, legal_limit)
        # --- Fin Ejemplo Conceptual ---

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">sanctions_private</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SANCION_PRIV co_partner ---
partner_id = None
# Las sanciones privadas generalmente no se pagan a un tercero (partner),
# sino que son una deducción directa. Si necesitas un partner por alguna razón
# específica de reporte o contabilidad, puedes usar la lógica de recurring_item.
# De lo contrario, para la mayoría de los casos de sanciones privadas,
# este campo podría no ser necesario o podría apuntar a la propia empresa.

# Ejemplo si se requiere un partner desde el item recurrente:
# RecurringItem = payslip.env.get('hr.employee.recurring.item')
# if RecurringItem and employee and contract and rule and payslip:
#     domain = [
#         ('employee_id', '=', employee.id),
#         ('contract_id', '=', contract.id),
#         ('recurring_item_type_id.salary_rule_id', '=', rule.id),
#         ('active', '=', True),
#         ('date_start', '<=', payslip.date_to),
#         '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
#     ]
#     recurring_item = RecurringItem.search(domain, limit=1)
#     if recurring_item and \
#        recurring_item.recurring_item_type_id and \
#        recurring_item.recurring_item_type_id.partner_id:
#         partner_id = recurring_item.recurring_item_type_id.partner_id.id

# Si la sanción es interna y no va a un tercero, puedes dejar partner_id como None
# o, si es necesario para la DIAN, podría ser el NIT de la propia empresa.
# Consulta los requisitos de la DIAN para el reporte de sanciones privadas.
# Si no se requiere un tercero, `result = None` es lo más apropiado.
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN PAGO A TERCEROS (PAGO_TERCERO - Recurrente) -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_pago_tercero" model="hr.salary.rule">
            <field name="name">Deducción Pago a Terceros</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">161</field>
            <field name="code">PAGO_TERCERO</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PAGO_TERCERO condition ---
result = False
# Consider adding employee type check if PAGO_TERCERO is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PAGO_TERCERO amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        if recurring_item.use_installments and recurring_item.remaining_balance > 0:
            # min() es una función built-in de Python y debería estar disponible
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)

        # --- CONSIDERAR LÍMITES LEGALES O REGLAMENTARIOS SI APLICAN ---
        # Dependiendo del tipo específico de "Pago a Terceros", podría haber límites.
        # Por ejemplo, si es un descuento por un préstamo de la empresa, podría tener
        # límites similares a las libranzas (50% del salario neto).
        # Si es un pago por servicios (ej. guardería), podría no tener límites legales,
        # pero sí un acuerdo con el empleado.
        # Debes validar si aplica algún límite para el tipo de pago a tercero específico.
        # Ejemplo conceptual (NO COMPLETO):
        # net_salary = categories.get('NET', 0.0) # O la base legal correcta
        # if recurring_item.recurring_item_type_id.code == 'PRESTAMO_EMPRESA': # Asume un campo 'code' en el tipo
        #    legal_limit = net_salary * 0.50
        #    amount_to_deduct = min(amount_to_deduct, legal_limit)
        # --- Fin Ejemplo Conceptual ---

        # 'precision_rounding' and 'payslip' are available from the preamble
        if not (abs(amount_to_deduct) < precision_rounding):
            if payslip and payslip.currency_id:
                result = payslip.currency_id.round(amount_to_deduct)
            else:
                result = round(amount_to_deduct, 2) # Fallback
        else:
            result = 0.0
            
# abs() es una función built-in de Python y debería estar disponible
result = -abs(result)
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">third_party_payments</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None: is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PAGO_TERCERO co_partner ---
partner_id = None
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    # Acceso directo a los campos, asumiendo que existen
    if recurring_item and \
       recurring_item.recurring_item_type_id and \
       recurring_item.recurring_item_type_id.partner_id: # Asume que partner_id es un campo Many2one a res.partner
        partner_id = recurring_item.recurring_item_type_id.partner_id.id
result = partner_id
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--     REGLA: DEDUCCIÓN ANTICIPO (ANTICIPO - Recurrente)       -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_anticipo" model="hr.salary.rule">
            <field name="name">Deducción Anticipo</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">162</field>
            <field name="code">ANTICIPO</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ANTICIPO condition ---
result = False
# Consider adding employee type check if ANTICIPO is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False), # Anticipos pueden no usar cuotas, sino un saldo a descontar
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ANTICIPO amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        # Para anticipos, es crucial descontar solo hasta el saldo restante.
        # Si 'use_installments' es False, 'remaining_balance' debería ser el total del anticipo a descontar.
        # Si 'use_installments' es True, se comporta como un préstamo por cuotas.
        if recurring_item.remaining_balance > 0:
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)
        else:
            # Si no hay saldo restante (o es cero/negativo), no se descuenta nada.
            # Esto es importante si el anticipo ya se pagó o si el ítem no está bien configurado.
            amount_to_deduct = 0.0
        
        result = amount_to_deduct
        # (Actualización de saldo/cuotas si aplica - IMPORTANTE para anticipos)
        # La actualización del saldo/cuotas del item recurrente debería manejarse
        # idealmente fuera de la regla salarial (ej. en el modelo hr.employee.recurring.item
        # o mediante una acción posterior a la confirmación de la nómina).
        # Este script solo calcula el monto a descontar en ESTA nómina.

# Standard currency rounding
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0

# abs() es una función built-in de Python y debería estar disponible
result = -abs(result) # Ensure negative for deduction
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">advances</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ANTICIPO co_partner ---
# Para anticipos, el "partner" es usualmente la propia empresa o no se especifica un tercero.
# Si la DIAN requiere el NIT de la empresa para reportar el descuento del anticipo,
# podrías obtenerlo de company_obj.partner_id.id.
# Si no se requiere un tercero específico, result = None es lo más apropiado.
partner_id = None
# Ejemplo: Si necesitas el NIT de la empresa:
# if company_obj and company_obj.partner_id:
#    partner_id = company_obj.partner_id.id
result = partner_id
                ]]>
            </field> 
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: DEDUCCIÓN REINTEGRO (REINTEGRO_DED - Recurrente)     -->
        <!-- =========================================================== -->
        <record id="hr_rule_deduccion_reintegro" model="hr.salary.rule">
            <field name="name">Deducción Reintegro</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">163</field>
            <field name="code">REINTEGRO_DED</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    # Acceso directo, asumiendo que el campo existe en hr.contract
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)
# ... Add other categories as needed ...

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    # Usar 'is not None' para campos personalizados que podrían no existir
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    # Acceso directo, asumiendo que el campo existe en res.company
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for REINTEGRO_DED condition ---
result = False
# Consider adding employee type check if REINTEGRO_DED is restricted (e.g., if not is_regular: result = False else: ...).
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search_count está disponible en el modelo
    if RecurringItem.search_count(domain) > 0:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract:
    if contract.integral_salary:
        is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)
# ... Add other categories as needed ...

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = contract.company_id if contract else None
if company_obj:
    if company_obj.smmlv_value is not None and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0:
        smmlv = company_obj.smmlv_value
    if company_obj.uvt_value is not None and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0:
        uvt_value = company_obj.uvt_value
    if company_obj.ley_1607 is not None:
        is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for REINTEGRO_DED amount ---
result = 0.0
# payslip.env está disponible en el contexto de las reglas
RecurringItem = payslip.env.get('hr.employee.recurring.item')
if RecurringItem and employee and contract and rule and payslip: # Asegurar que los objetos base existen
    domain = [
        ('employee_id', '=', employee.id),
        ('contract_id', '=', contract.id),
        ('recurring_item_type_id.salary_rule_id', '=', rule.id),
        ('active', '=', True),
        ('date_start', '<=', payslip.date_to),
        '|', ('date_end', '=', False), ('date_end', '>=', payslip.date_from),
        '|', ('use_installments', '=', False),
             '&', ('use_installments', '=', True),
                  '|', ('remaining_installments', '>', 0),
                       ('remaining_balance', '>', 0.0)
    ]
    # search está disponible en el modelo
    recurring_item = RecurringItem.search(domain, limit=1)

    if recurring_item:
        amount_to_deduct = 0.0
        # Acceso directo a los campos del item recurrente
        if recurring_item.amount_type == 'fix':
            amount_to_deduct = recurring_item.amount
        elif recurring_item.amount_type == 'percentage':
            base_value = 0.0
            if recurring_item.percentage_base_rule_code:
                # 'categories' is available from the preamble
                base_value = categories.get(recurring_item.percentage_base_rule_code, 0.0)
            else:
                base_value = recurring_item.amount # Fallback
            amount_to_deduct = base_value * (recurring_item.percentage / 100.0)

        # Para reintegros, es crucial descontar solo hasta el saldo restante.
        if recurring_item.remaining_balance > 0:
            amount_to_deduct = min(amount_to_deduct, recurring_item.remaining_balance)
        else:
            # Si no hay saldo restante (o es cero/negativo), no se descuenta nada.
            amount_to_deduct = 0.0
        
        result = amount_to_deduct
        # (Actualización de saldo/cuotas si aplica - IMPORTANTE para reintegros)
        # La actualización del saldo/cuotas del item recurrente debería manejarse
        # idealmente fuera de la regla salarial (ej. en el modelo hr.employee.recurring.item
        # o mediante una acción posterior a la confirmación de la nómina).
        # Este script solo calcula el monto a descontar en ESTA nómina.

# Standard currency rounding
if not (abs(result) < precision_rounding):
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(result)
    else:
        result = round(result, 2) # Fallback
else:
    result = 0.0

# abs() es una función built-in de Python y debería estar disponible
result = -abs(result) # Ensure negative for deduction
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">refund</field> <!-- Categoría igual al devengo -->
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field> <!-- Reintegro es a la compañía -->
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: OTRA DEDUCCIÓN (OTRA_DED - Manual)              -->
        <!-- =========================================================== -->
        <record id="hr_rule_otra_deduccion" model="hr.salary.rule">
            <field name="name">Otra Deducción</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">164</field>
            <field name="code">OTRA_DED</field>
            <field name="category_id" ref="hr_payroll.DED"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)
# ... Add other categories as needed ...

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for OTRA_DED condition ---
result = False
otra_ded_value = 0.0

# Safely get OTRA_DED value from inputs
# inputs es un diccionario de objetos hr.payslip.input
# El objeto 'inputs' está disponible en el contexto de la condición.
# Suponemos que 'OTRA_DED' es el código de una línea de entrada (Other Input).
otra_ded_input_line = None
if inputs: # Verificar que 'inputs' no sea None
    try:
        otra_ded_input_line = inputs.get('OTRA_DED')
    except Exception: # Captura genérica si .get() falla o 'inputs' no es un dict
        otra_ded_input_line = None

if otra_ded_input_line: # Check if the input line object exists
    try:
        # 'amount' is a standard field on hr.payslip.input objects
        # Accedemos a 'amount'. Si no existe en otra_ded_input_line, el try/except lo manejará.
        otra_ded_value = float(otra_ded_input_line.amount or 0.0)
    except (ValueError, TypeError, AttributeError): # For safety during float conversion or if 'amount' doesn't exist
        otra_ded_value = 0.0

# Condition: Applies if a positive value is provided in the input.
# precision_rounding viene del preámbulo.
if otra_ded_value > precision_rounding: # Comparar con precision_rounding para evitar problemas con floats muy pequeños
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
apoyo_sost = categories.get('APOYO_SOST', 0.0)
# ... Add other categories as needed ...

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for OTRA_DED amount ---
result = 0.0

# Safely get OTRA_DED value from inputs
# El objeto 'inputs' está disponible en el contexto del cálculo.
otra_ded_input_line = None
if inputs: # Verificar que 'inputs' no sea None
    try:
        otra_ded_input_line = inputs.get('OTRA_DED')
    except Exception: # Captura genérica si .get() falla o 'inputs' no es un dict
        otra_ded_input_line = None
        
calculated_amount = 0.0
if otra_ded_input_line: # Check if the input line object exists
    try:
        # 'amount' is a standard field on hr.payslip.input objects
        # Accedemos a 'amount'. Si no existe en otra_ded_input_line, el try/except lo manejará.
        calculated_amount = float(otra_ded_input_line.amount or 0.0)
    except (ValueError, TypeError, AttributeError): # For safety during float conversion or if 'amount' doesn't exist
        calculated_amount = 0.0

# Reemplazo de float_is_zero(calculated_amount, precision_rounding=precision_rounding)
# precision_rounding viene del preámbulo.
if abs(calculated_amount) < precision_rounding:
    result = 0.0
else:
    result = abs(calculated_amount) # Ensure negative for deduction, abs() is built-in
                ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <field name="type_concept">deduction</field>
            <field name="deduction_category">other_deductions</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">default</field>
            <field name="co_partner_select">default</field> <!-- Genérica, sin partner específico -->
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: BASE PARA CÁLCULO PRESTACIONES SOCIALES (Condición Ajustada para Integral) -->
        <!-- =========================================================== -->
        <record id="hr_rule_base_prestaciones" model="hr.salary.rule">
            <field name="name">Base Prestaciones Sociales (Con Aux. Trans.)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">102</field> <!-- Después de IBC -->
            <field name="code">BASE_PRESTACIONES</field>
            <field name="category_id" ref="hr_payroll.BASIC"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - CORREGIDO)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.

# --- Employee Type Determination (CORREGIDO para Aprendices) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: # Asumimos que 'contract' existe
    try: # Para contract.integral_salary
        if contract.integral_salary: # Campo booleano 'Salario integral'
            is_integral = True
    except AttributeError:
        pass # is_integral permanece False

    try: # Para contract.type_worker_id.code (Tipos de trabajador DIAN)
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass # variables de aprendiz permanecen False
            
    # Determina si es regular (ni integral, ni aprendiz)
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- El resto del preámbulo (smmlv, uvt, exonerated, currency_rounding, precision_rounding) ---
# --- se mantiene como lo tienes, ya que no afecta la lógica de activación del IBC ---
# --- y ya usa acceso directo y try-except donde es necesario.                 ---

# --- Company specific values (acceso directo y try-except) ---
smmlv = 0.0
# uvt_value = 0.0 # No se usa en la condición específica del IBC
# is_exonerated_company = False # No se usa en la condición específica del IBC
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0 
    # No necesitamos uvt_value ni is_exonerated_company para la condición de la regla IBC.

# --- Common helper variables (precision_rounding se usa implícitamente si float_is_zero fuera usado) ---
# precision_rounding = 0.01 # Default
# try: 
#     if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
#         current_payslip_currency_rounding_val = payslip.currency_id.rounding
#         temp_float_rounding = float(current_payslip_currency_rounding_val)
#         if 0.0 <= temp_float_rounding <= 1.0 : 
#             precision_rounding = temp_float_rounding
# except (AttributeError, ValueError, TypeError):
#     pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for BASE_PRESTACIONES condition ---
# La regla aplica si hay contrato Y NO es aprendiz Y NO es integral
# is_any_apprentice e is_integral vienen del preámbulo.
result = bool(contract and not is_any_apprentice and not is_integral)
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
result = categories.get('IBC', 0.0) + categories.get('BASE_PRESTACIONES', 0.0)
result = round(result, 0)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: APORTE EMPLEADOR SALUD (SALUD_PAT) - REGULAR    -->
        <!-- =========================================================== -->
        <record id="hr_rule_aporte_salud_empleador_regular" model="hr.salary.rule">
            <field name="name">Aporte Salud Empleador (Regular 8.5%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">200</field> <!-- Secuencia para aportes empleador -->
            <field name="code">SALUD_PAT</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
# --- Employee Type Determination (Tu lógica actual para esto parece correcta) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract: # Asumimos que 'contract' existe
    try:
        if contract.integral_salary:
            is_integral = True
    except AttributeError: pass
    try:
        if contract.type_worker_id and contract.type_worker_id.code:
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True; is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True; is_any_apprentice = True
    except AttributeError: pass
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# AJUSTA 'IBC_BASE_SALUD' AL CÓDIGO DE TU CATEGORÍA que contiene el IBC para Salud.
# Podría ser 'CALCULO' si es la misma base general, o una específica como 'IBC_SS' o 'IBC_SALUD'.
ibc = categories.get('IBC', 0.0) 

# --- Company specific values ---
smmlv = 0.0
is_exonerated_company = False # <--- NECESARIO CARGAR ESTA VARIABLE
company_obj_cond = None
if contract and contract.company_id:
    company_obj_cond = contract.company_id

if company_obj_cond:
    try: # Cargar SMMLV
        smmlv_from_company = company_obj_cond.smmlv_value
        if smmlv_from_company is not None:
            temp_smmlv = float(smmlv_from_company)
            if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError): smmlv = 0.0
    
    try: # Cargar is_exonerated_company (usa el nombre de campo correcto 'ley_1607')
        is_exonerated_company = bool(company_obj_cond.ley_1607)
    except AttributeError: is_exonerated_company = False

# --- Common helper variables ---
precision_rounding = 0.01
currency_rounding = 0.01 # Default
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 :
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding # Actualizar precision_rounding también
except (AttributeError, ValueError, TypeError): pass
# ======================================================
# Common Preamble for Salary Rules - END (CORREGIDO)
# ======================================================

# --- Specific Rule Logic for SALUD_PAT condition ---
result = False
eps_fund_exists = False # Verifica si el empleado tiene una EPS asignada en el contrato
try:
    if contract and contract.eps_id:
        eps_fund_exists = True
except AttributeError: pass

if eps_fund_exists:
    condition_ibc_not_zero = not (abs(ibc) < precision_rounding)

    # Esta lógica se enfoca en empleados regulares e integrales.
    # La salud de aprendices usualmente se maneja diferente (base 1 SMMLV, siempre pagada por empleador).
    if not is_any_apprentice:
        if (is_regular or is_integral) and condition_ibc_not_zero:
            # LÓGICA DE EXONERACIÓN APLICADA AQUÍ:
            # La regla se activa (result = True) si:
            # 1. La empresa NO está exonerada (paga siempre por estos empleados).
            # O
            # 2. La empresa SÍ está exonerada PERO el IBC del empleado es >= 10 SMMLV.
            # Se usa (10 * smmlv - precision_rounding) para una comparación más segura con flotantes,
            # asegurando que si ibc es, por ejemplo, 9.99999*SMMLV, se considere menor.
            if not is_exonerated_company or \
               (is_exonerated_company and smmlv > 0 and ibc >= (10 * smmlv - precision_rounding)):
                result = True
            # Si la empresa está exonerada y el IBC del empleado es < 10 SMMLV, result permanece False.
    # else: 
        # Si esta regla también debe cubrir la salud de aprendices (base 1 SMMLV):
        # if (is_apprentice_lectiva or is_apprentice_productiva) and smmlv > 0:
        #     result = True # El empleador siempre paga salud por aprendices.
        # El amount_python_compute necesitaría usar smmlv como base para aprendices.
        # Por ahora, nos centramos en la exoneración para regulares/integrales.
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# (Solo las variables realmente necesarias para este cómputo)
# ======================================================
# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) 

# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALUD_PAT amount ---
result = 0.0 
# La condición ya filtró los casos donde no aplica.
# ibc es del preámbulo simplificado.

# Cálculo base Salud Empleador (8.5% estándar para regulares no exonerados o >10SMMLV)
# Para empleados integrales, el empleador también paga el 8.5% sobre el 70% del integral.
# La lógica de exoneración ya fue manejada en la condition_python.
aporte_base = ibc * 0.085

# Reemplazo de not float_is_zero(aporte_base, ...)
condition_aporte_base_not_zero = not (abs(aporte_base) < precision_rounding)

# Aplicar redondeo PILA a la centena superior (sin math.ceil)
if condition_aporte_base_not_zero:
    _value_to_round_up = aporte_base
    _multiple = 100.0
    
    if _value_to_round_up > 0:
        # Comprobación más segura para múltiplos con flotantes
        if abs(_value_to_round_up % _multiple) < precision_rounding or abs(_value_to_round_up % _multiple - _multiple) < precision_rounding:
             result = _value_to_round_up
        else:
             result = (float(int(_value_to_round_up / _multiple)) + 1.0) * _multiple
    # else: result permanece 0.0 si aporte_base era negativo o cero
else:
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field>
            <field name="edi_percent_fix">8.5</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                 <![CDATA[
# ======================================================
# Preámbulo Mínimo para co_partner_python_compute
# ======================================================
result = None 
try:
    if contract and contract.eps_id and contract.eps_id.partner_id:
        result = contract.eps_id.partner_id.id
except AttributeError:
    result = None
                 ]]>
             </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: APORTE EMPLEADOR PENSIÓN (PENSION_PAT) - AJUSTADA -->
        <!-- =========================================================== -->
        <record id="hr_rule_aporte_pension_empleador" model="hr.salary.rule">
            <field name="name">Aporte Pensión Empleador (12%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">201</field>
            <field name="code">PENSION_PAT</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False

if contract: # Asumimos que 'contract' existe o la regla no debería evaluarse
    try: # Para contract.integral_salary
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass # is_integral permanece False

    try: # Para contract.type_worker_id.code
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': 
                is_apprentice_lectiva = True
                is_any_apprentice = True
            elif worker_type_code_dian == '19': 
                is_apprentice_productiva = True
                is_any_apprentice = True
    except AttributeError:
        pass # variables de aprendiz permanecen False
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# IBC (seq 100) - DISPONIBLE para PENSION_PAT (seq 201)
ibc = categories.get('IBC', 0.0) 

# --- Company specific values (acceso directo y try-except) ---
smmlv = 0.0
# uvt_value y is_exonerated_company no se usan en esta condición específica
# pero se podrían definir si el preámbulo es estrictamente común a todas las reglas.
# Por ahora, solo definimos smmlv que sí podría ser relevante para topes o mínimos si aplicaran aquí.
company_obj_cond = None
if contract and contract.company_id: 
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError):
        smmlv = 0.0

# --- Common helper variables (acceso directo y try-except) ---
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PENSION_PAT condition ---
result = False
# Aplica si es Empleado Regular o Integral.
# CRÍTICO: Debe tener el Fondo de Pensión asignado en el contrato.
# is_regular, is_integral, ibc son del preámbulo.
pension_fund_exists = False
try:
    if contract and contract.pension_id: # Acceso directo
        pension_fund_exists = True
except AttributeError:
    pass # pension_fund_exists permanece False

if pension_fund_exists:
    # abs(ibc) < precision_rounding es el reemplazo de float_is_zero(ibc, ...)
    if (is_regular or is_integral) and not (abs(ibc) < precision_rounding):
        result = True
# NOTA: No aplica a Aprendices (ya cubierto por is_regular/is_integral)
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# (Solo las variables realmente necesarias para este cómputo)
# ======================================================
# --- Fetching key values from categories ---
ibc = result = result_rules['IBC_BASE']['total'] if 'IBC_BASE' in result_rules else 0.0    

# --- Common helper variables (acceso directo y try-except) ---
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PENSION_PAT amount ---
result = 0.0
# ibc es del preámbulo simplificado arriba

# Cálculo base Pensión (12% estándar empleador)
aporte_base = ibc * 0.12 # Asumir 12% fijo

# Replaces: not float_is_zero(aporte_base, precision_rounding=precision_rounding)
condition_aporte_base_not_zero = not (abs(aporte_base) < precision_rounding)

# Aplicar redondeo PILA a la centena superior (sin math.ceil)
if condition_aporte_base_not_zero:
    _value_to_round_up = aporte_base
    _multiple = 100.0
    
    if _value_to_round_up > 0: # Solo redondear positivos, sino result es 0
        # Comprobación más segura para múltiplos con flotantes
        if abs(_value_to_round_up % _multiple) < precision_rounding or abs(_value_to_round_up % _multiple - _multiple) < precision_rounding :
             result = _value_to_round_up # Ya es un múltiplo (o muy cercano)
        else:
             result = (float(int(_value_to_round_up / _multiple)) + 1.0) * _multiple
    # else: result permanece 0.0
else:
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field>
            <field name="edi_percent_fix">12.0</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                 <![CDATA[
# ======================================================
# Preámbulo Mínimo para co_partner_python_compute
# ======================================================
result = None 
try:
    if contract and contract.eps_id and contract.pension_id.partner_id:
        result = contract.pension_id.partner_id.id
except AttributeError:
    result = None
                 ]]>
             </field>
        </record>

        <!-- =========================================================== -->
        <!-- REGLA: APORTE ARL EMPLEADOR - AJUSTADA (Nombre de campo ARL)-->
        <!-- =========================================================== -->
       <record id="hr_rule_aporte_arl_empleador" model="hr.salary.rule">
            <field name="name">Aporte ARL Empleador</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">202</field>
            <field name="code">ARL_PAT</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env
# --- Python Built-ins ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination (Basado en Tipo de Trabajador DIAN desde el Contrato) ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False 
is_apprentice_productiva = False
is_any_apprentice = False 

if contract:
    if contract.integral_salary: 
        is_integral = True
    
    if contract.type_worker_id and contract.type_worker_id.code: 
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': 
            is_apprentice_lectiva = True
            is_any_apprentice = True 
        elif dian_worker_type_code == '19': 
            is_apprentice_productiva = True
            is_any_apprentice = True 

if not is_integral and not is_any_apprentice:
    is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) 

# --- Company specific values ---
smmlv = 0.0
company_obj = None
if contract and contract.company_id: 
    company_obj = contract.company_id
if company_obj:
    smmlv_from_company = company_obj.smmlv_value 
    temp_smmlv = 0.0
    try: 
        temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : 
            currency_rounding = test_float
            precision_rounding = test_float
    except (ValueError, TypeError): pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ARL_PAT condition ---
result = False
arl_risk_level_obj = None 

if contract:
    # arl_risk_level SÍ existe en hr.contract según tu información
    arl_risk_level_obj = contract.arl_risk_level 

# Aplica si tiene Nivel de Riesgo ARL asignado (ya no se verifica arl_id aquí)
# Y (es Regular/Integral con IBC > 0, O Aprendiz Productiva con SMMLV > 0).
if arl_risk_level_obj: # Solo necesitamos que el nivel de riesgo exista para obtener el %
    if (is_regular or is_integral) and not (abs(ibc) < precision_rounding): # ibc > 0
        result = True
    elif is_apprentice_productiva and smmlv > precision_rounding: # smmlv > 0
        result = True
# NOTA: No aplica a Aprendices Lectiva.
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3) - Reaplicado aquí
# ======================================================
# (Mismo preámbulo que en condition_python, definiendo is_regular, is_integral, 
#  is_apprentice_productiva, ibc, smmlv, precision_rounding, currency_rounding, etc.)
# --- Employee Type Determination ---
is_regular = False; is_integral = False; is_apprentice_productiva = False 
if contract:
    if contract.integral_salary: is_integral = True
    if contract.type_worker_id and contract.type_worker_id.code: 
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '19': is_apprentice_productiva = True
    # is_regular se define aquí para el contexto del cálculo de base_arl
    if not is_integral and not is_apprentice_productiva and not (contract.type_worker_id and contract.type_worker_id.code == '12'):
        is_regular = True
# --- Fetching key values & Company values ---
ibc = result = result_rules['IBC_BASE']['total'] if 'IBC_BASE' in result_rules else 0.0    

smmlv = 0.0
company_obj = contract.company_id if contract else None
if company_obj:
    smmlv_from_company = company_obj.smmlv_value 
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
# --- Common helper variables ---
currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for ARL_PAT amount ---
result = 0.0
result_qty = 1.0 
base_arl = 0.0
arl_percentage = 0.0

arl_risk_level_obj = None
if contract:
    arl_risk_level_obj = contract.arl_risk_level # Acceso directo

if arl_risk_level_obj:
    raw_arl_percentage = None
    try:
        raw_arl_percentage = arl_risk_level_obj.percentage 
    except Exception: pass

    if raw_arl_percentage is not None:
        try:
            arl_percentage = float(raw_arl_percentage)
        except (ValueError, TypeError):
            arl_percentage = 0.0 
else:
    arl_percentage = 0.0 

if is_regular or is_integral:
    base_arl = ibc
elif is_apprentice_productiva:
    base_arl = smmlv 

if not (abs(base_arl) < precision_rounding) and arl_percentage > 0:
    aporte_calculado = base_arl * (arl_percentage / 100.0)
    
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(aporte_calculado)
    else:
        result = round(aporte_calculado, 0) 
else:
    result = 0.0

if abs(result) < precision_rounding: 
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">code</field>
            <field name="edi_percent_python_compute">
                <![CDATA[
# Preamble para obtener arl_risk_level.percentage
arl_percentage_edi = 0.0
if contract: 
    arl_risk_level_obj_edi = None
    try:
        arl_risk_level_obj_edi = contract.arl_risk_level 
    except Exception: pass 
        
    if arl_risk_level_obj_edi:
        raw_arl_percentage_edi = None
        try:
            raw_arl_percentage_edi = arl_risk_level_obj_edi.percentage 
        except Exception: pass

        if raw_arl_percentage_edi is not None:
            try:
                arl_percentage_edi = float(raw_arl_percentage_edi)
            except (ValueError, TypeError):
                pass 
result = arl_percentage_edi
                ]]>
            </field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START
# ======================================================
from odoo.tools import float_is_zero, float_compare # Always useful for numeric comparisons
# import math # Only if you use math functions (ceil, etc.)
# import logging # Import logging if you need to log messages within the script
# _logger = logging.getLogger(__name__) # Initialize logger if logging is imported

# --- Environment objects (Automatically available) ---
# payslip: hr.payslip record for the current payslip
# employee: hr.employee record
# contract: hr.contract record
# categories: Dictionary with results of rules with lower sequence (e.g., categories.get('IBC', 0.0))
# inputs: Dictionary with amounts from payslip.input_line_ids (e.g., inputs.get('MANUAL_CODE', 0.0))
# worked_days: Dictionary with worked_days_line_ids (e.g., worked_days.get('ATT', None))
# rule: hr.salary.rule record of the current rule
# env: Odoo environment object (use payslip.env for safer access in sandbox)

# --- Employee Type Determination ---
# Not strictly needed for this specific partner logic, but included for consistency
is_regular = False; is_integral = False; is_apprentice_lectiva = False; is_apprentice_productiva = False; is_any_apprentice = False
if contract:
    if hasattr(contract, 'integral_salary') and contract.integral_salary: is_integral = True
    elif contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4': is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5': is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice: is_regular = True

# --- Fetching key values from categories ---
# ibc = categories.get('IBC', 0.0) # Example, uncomment if needed
# apoyo_sost = categories.get('APOYO_SOST', 0.0) # Example, uncomment if needed

# --- Company specific values ---
# Not strictly needed for this specific partner logic
smmlv = 0.0; uvt_value = 0.0; is_exonerated_company = False
# company_obj = contract.company_id if contract else None
# if company_obj:
#     if hasattr(company_obj, 'smmlv_value') and isinstance(company_obj.smmlv_value, (int, float)) and company_obj.smmlv_value > 0: smmlv = company_obj.smmlv_value
#     if hasattr(company_obj, 'uvt_value') and isinstance(company_obj.uvt_value, (int, float)) and company_obj.uvt_value > 0: uvt_value = company_obj.uvt_value
#     if hasattr(company_obj, 'ley_1607'): is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
# Not strictly needed for this specific partner logic
# currency_rounding = payslip.currency_id.rounding if payslip and payslip.currency_id else 0.01
# precision_rounding = currency_rounding
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================
# Partner es la ARL asignada en el contrato
result = contract.arl_id.partner_id.id if contract and hasattr(contract, 'arl_id') and contract.arl_id and hasattr(contract.arl_id, 'partner_id') and contract.arl_id.partner_id else None
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: APORTE EMPLEADOR SENA - AJUSTADA                -->
        <!-- =========================================================== -->
        <record id="hr_rule_aporte_sena_empleador" model="hr.salary.rule">
            <field name="name">Aporte SENA Empleador (2%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">210</field>
            <field name="code">SENA_PAT</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) 
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for SENA_PAT condition ---
result = False
# is_regular, is_integral, ibc, is_exonerated_company, smmlv son del preámbulo.
# is_any_apprentice también está disponible desde el preámbulo.

# Reemplazo de float_is_zero(ibc, precision_rounding=precision_rounding)
condition_ibc_not_zero = not (abs(ibc) < precision_rounding)

if not is_any_apprentice: # No aplica a ningún tipo de aprendiz
    # Condición para empleados regulares
    condition_regular = (is_regular and condition_ibc_not_zero and
                         (not is_exonerated_company or (smmlv > 0 and ibc >= (10 * smmlv))))
    
    # Condición para empleados con salario integral
    condition_integral = (is_integral and condition_ibc_not_zero)
    
    if condition_regular or condition_integral:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)    
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for SENA_PAT amount ---
# ibc es del preámbulo
# Cálculo base SENA (2%)
aporte_base = ibc * 0.02

# Aplicar redondeo PILA a la centena superior (sin math.ceil)
result = 0.0
# Reemplazo de float_is_zero(aporte_base, precision_rounding=precision_rounding)
condition_aporte_base_not_zero = not (abs(aporte_base) < precision_rounding)

if condition_aporte_base_not_zero:
    _value_to_round_up = aporte_base
    _multiple = 100.0
    if _value_to_round_up > 0: # El aporte debe ser positivo
        # Verificar si es un múltiplo exacto
        if _value_to_round_up % _multiple == 0:
             result = _value_to_round_up
        else:
             # Redondear al siguiente múltiplo de 100
             result = (int(_value_to_round_up / _multiple) + 1) * _multiple
    # Si aporte_base es 0 o negativo (improbable aquí), result permanece 0.0
# Si aporte_base es considerado cero, result permanece 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field>
            <field name="edi_percent_fix">2.0</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: APORTE ICBF EMPLEADOR - AJUSTADA                -->
        <!-- =========================================================== -->
        <record id="hr_rule_aporte_icbf_empleador" model="hr.salary.rule">
            <field name="name">Aporte ICBF Empleador (3%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">211</field>
            <field name="code">ICBF_PAT</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for ICBF_PAT condition ---
result = False
# is_regular, is_integral, ibc, is_exonerated_company, smmlv, is_any_apprentice son del preámbulo.

# Reemplazo de float_is_zero(ibc, precision_rounding=precision_rounding)
condition_ibc_not_zero = not (abs(ibc) < precision_rounding)

if not is_any_apprentice: # No aplica a ningún tipo de aprendiz
    # Condición para empleados regulares
    condition_regular = (is_regular and condition_ibc_not_zero and
                         (not is_exonerated_company or (smmlv > 0 and ibc >= (10 * smmlv))))
    
    # Condición para empleados con salario integral
    condition_integral = (is_integral and condition_ibc_not_zero)
    
    if condition_regular or condition_integral:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = result = result_rules['IBC_BASE']['total'] if 'IBC_BASE' in result_rules else 0.0    
# apoyo_sost = categories.get('APOYO_SOST', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for ICBF_PAT amount ---
# ibc es del preámbulo
# Cálculo base ICBF (3%)
aporte_base = ibc * 0.03

# Aplicar redondeo PILA a la centena superior (sin math.ceil)
result = 0.0
# Reemplazo de float_is_zero(aporte_base, precision_rounding=precision_rounding)
condition_aporte_base_not_zero = not (abs(aporte_base) < precision_rounding)

if condition_aporte_base_not_zero:
    _value_to_round_up = aporte_base
    _multiple = 100.0
    if _value_to_round_up > 0: # El aporte debe ser positivo
        # Verificar si es un múltiplo exacto
        if _value_to_round_up % _multiple == 0:
             result = _value_to_round_up
        else:
             # Redondear al siguiente múltiplo de 100
             result = (int(_value_to_round_up / _multiple) + 1) * _multiple
    # Si aporte_base es 0 o negativo (improbable aquí), result permanece 0.0
# Si aporte_base es considerado cero, result permanece 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field>
            <field name="edi_percent_fix">3.0</field>
            <field name="co_partner_select">default</field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: APORTE EMPLEADOR CCF (CCF_PAT) - AJUSTADA       -->
        <!-- =========================================================== -->
        <record id="hr_rule_aporte_ccf_empleador" model="hr.salary.rule">
            <field name="name">Aporte CCF Empleador (4%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">212</field>
            <field name="code">CCF_PAT</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False # Para referencia general

if contract:
    try:
        if contract.integral_salary:
            is_integral = True
    except AttributeError: pass

    try:
        if contract.type_worker_id and contract.type_worker_id.code:
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12': # Aprendiz SENA Etapa Lectiva (DIAN)
                is_apprentice_lectiva = True; is_any_apprentice = True
            elif worker_type_code_dian == '19': # Aprendiz SENA Etapa Productiva (DIAN)
                is_apprentice_productiva = True; is_any_apprentice = True
    except AttributeError: pass
        
    if not is_integral and not is_any_apprentice: # is_regular si no es integral ni NINGÚN tipo de aprendiz
        is_regular = True

# --- Fetching key values from categories ---
# Para la CONDICIÓN, verificaremos la base específica en cada caso.
# 'CALCULO' es la categoría donde está el IBC general.
ibc_general_calculo = categories.get('CALCULO', 0.0) # Se usará si es la base para regulares.

# --- Company specific values ---
smmlv = 0.0
# is_exonerated_company = False # NO SE USA PARA LA CONDICIÓN DE CCF
precision_rounding = 0.01 # Asumido del preámbulo original
company_obj_cond = None
if contract and contract.company_id:
    company_obj_cond = contract.company_id

if company_obj_cond:
    try:
        smmlv_from_company = company_obj_cond.smmlv_value
        if smmlv_from_company is not None:
            temp_smmlv = float(smmlv_from_company)
            if temp_smmlv > 0: smmlv = temp_smmlv
    except (AttributeError, ValueError, TypeError): smmlv = 0.0
# No es necesario cargar is_exonerated_company para la condición de CCF.
# ======================================================
# Common Preamble for Salary Rules - END (Ajustado para CCF Condition)
# ======================================================

# --- Specific Rule Logic for CCF_PAT condition ---
result = False
ccf_assigned = False
try:
    if contract and contract.ccf_id: # Caja de Compensación asignada
        ccf_assigned = True
except AttributeError: pass

contract_wage_value = 0.0 # Para base de integral
if contract:
    try: contract_wage_value = float(contract.wage or 0.0)
    except: contract_wage_value = 0.0

if ccf_assigned:
    base_positive_for_ccf = False
    if is_regular:
        # Base para regulares: Usa ibc_general_calculo.
        # Asegúrate que esta categoría ('CALCULO') contenga Aux. Transporte si aplica para CCF.
        if not (abs(ibc_general_calculo) < precision_rounding):
            base_positive_for_ccf = True
            
    elif is_integral:
        # Base para integrales es 100% de contract.wage.
        if not (abs(contract_wage_value) < precision_rounding):
            base_positive_for_ccf = True
            
    elif is_apprentice_productiva:
        # Base para aprendices productivos es SMMLV.
        if not (abs(smmlv) < precision_rounding): # smmlv > 0
            base_positive_for_ccf = True
            
    # Aprendices en etapa lectiva no pagan CCF (no se establece base_positive_for_ccf = True).

    if base_positive_for_ccf:
        result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble (Solo lo necesario)
# ======================================================
# 'CALCULO' es la CATEGORÍA donde está el resultado de tu regla IBC (código IBC)
ibc = result = result_rules['IBC_BASE']['total'] if 'IBC_BASE' in result_rules else 0.0     
smmlv = 0.0
precision_rounding = 0.01
currency_rounding = 0.01
company_obj_amount = None

# Re-definir is_regular, is_integral, is_apprentice_productiva para este scope
is_regular = False
is_integral = False
is_apprentice_productiva = False # Solo necesitamos este para la base

if contract: 
    company_obj_amount = contract.company_id
    try:
        if contract.integral_salary: is_integral = True
    except AttributeError: pass
    try:
        if contract.type_worker_id and contract.type_worker_id.code == '19': 
            is_apprentice_productiva = True
    except AttributeError: pass
    # is_any_apprentice no es necesario para la lógica de monto aquí
    if not is_integral and not (contract.type_worker_id and contract.type_worker_id.code in ['12','19']): # Ajuste a is_any_apprentice
        is_regular = True

if company_obj_amount:
    try:
        smmlv_from_company = company_obj_amount.smmlv_value 
        if smmlv_from_company is not None:
             temp_smmlv = float(smmlv_from_company)
             if temp_smmlv > 0: smmlv = temp_smmlv
    except: smmlv = 0.0 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        temp_cr = float(payslip.currency_id.rounding)
        if 0.0 <= temp_cr <= 1.0 : currency_rounding = temp_cr
except: pass
precision_rounding = currency_rounding if currency_rounding != 0 else 0.01
# ======================================================

# --- Specific Rule Logic for CCF_PAT amount ---
result = 0.0
base_ccf = 0.0

if is_regular:
    base_ccf = ibc # Para regulares, base es el IBC (que ya excluye Aux Trans si no es factor salarial)
elif is_integral:
    # Para integrales, la base de CCF es el 70% del salario integral
    # La condición ya manejó la exoneración vs. tope de 10 SMMLV.
    try:
        base_ccf = ibc
    except (AttributeError, ValueError, TypeError):
        base_ccf = 0.0
elif is_apprentice_productiva: 
    base_ccf = smmlv # Para aprendices productivos, la base es 1 SMMLV

if not (abs(base_ccf) < precision_rounding): # Si la base_ccf es > 0
    aporte_base = base_ccf * 0.04
    if not (abs(aporte_base) < precision_rounding):
        # Redondeo PILA a la centena superior
        _value_to_round_up = aporte_base
        _multiple = 100.0
        if _value_to_round_up > 0:
            if abs(_value_to_round_up % _multiple) < precision_rounding or abs(_value_to_round_up % _multiple - _multiple) < precision_rounding :
                 result = _value_to_round_up
            else:
                 result = (float(int(_value_to_round_up / _multiple)) + 1.0) * _multiple
        # else: result permanece 0.0 si aporte_base es negativo o cero
    # else: result permanece 0.0
# else: result permanece 0.0 (si base_ccf es cero)
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">fix</field>
            <field name="edi_percent_fix">4.0</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) para CCF_PAT
# Obtiene el partner de la Caja de Compensación (ccf_id)
# asignada en el contrato del empleado.
# ======================================================
result = None
try:
    # 'contract' es el registro del contrato actual.
    # 'ccf_id' en el contrato es una relación al modelo de tu caja de compensación (l10n_co_nomina.ccf).
    # Asumimos que ese modelo 'l10n_co_nomina.ccf' tiene un campo llamado 'partner_id' 
    # que es la relación al partner (res.partner) de la entidad CCF.

    if contract and contract.ccf_id and contract.ccf_id.partner_id:
        # Accede al ID del partner_id que está en el registro de ccf_id
        result = contract.ccf_id.partner_id.id
    # else: si alguna condición no se cumple, result permanece None

except Exception: # Cambiado de AttributeError a Exception
    # Captura cualquier error durante el acceso a los atributos y asigna None.
    # Esto es más seguro en el entorno restringido donde 'AttributeError' no está definido.
    result = None
# 'result' contendrá el ID del partner de la CCF o None.
                ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: PROVISIÓN CESANTÍAS (PROV_CES) - AJUSTADA       -->
        <!-- =========================================================== -->
        <record id="hr_rule_provision_cesantias" model="hr.salary.rule">
            <field name="name">Provisión Cesantías (8.33%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">250</field> <!-- Secuencia para provisiones -->
            <field name="code">PROV_CES</field>
            <field name="category_id" ref="hr_payroll.COMP"/> <!-- Categoría Contribuciones Compañía -->
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False 
is_any_apprentice = False # Para esta regla, aprendices no deberían provisionar cesantías de esta forma.

if contract: 
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12' or worker_type_code_dian == '19': 
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# Se asume que BASE_PRESTACIONES (ej. seq 102) ya se calculó y está disponible
base_prestaciones = categories.get('BASE_PRESTACIONES', 0.0) 

# --- Common helper variables ---
precision_rounding = 0.01 # Para comparaciones > 0
# No se necesita currency_rounding en esta condición específica
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PROV_CES condition ---
# La provisión de cesantías aplica a empleados REGULARES.
# Los integrales tienen las cesantías incluidas en su 70% prestacional (manejado en su pago).
# Los aprendices no generan cesantías de esta forma.
# La provisión se hace si la base de prestaciones es mayor a cero.
result = False
if is_regular and not (abs(base_prestaciones) < precision_rounding):
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PROV_CES amount ---
result = 0.0 
base_para_provision = 0.0

base_para_provision = categories.get('IBC_AUX', 0.0)


if not (abs(base_para_provision) < precision_rounding):
    provision_calculada = base_para_provision * (1.0 / 12.0) 

    num_decimals = 2 
    if currency_rounding == 0.01: num_decimals = 2
    elif currency_rounding == 1.0: num_decimals = 0
    
    if num_decimals >= 0:
        factor = 10 ** num_decimals
        result = float(int(provision_calculada * factor + (0.5 if provision_calculada >=0 else -0.5))) / factor
    else: 
        factor = 10 ** abs(num_decimals)
        result = float(int(provision_calculada / factor + (0.5 if provision_calculada >=0 else -0.5))) * factor
else:
    result = 0.0 
            ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
            ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: PROVISIÓN INTERESES CESANTÍAS (PROV_INTCES) - AJUSTADA -->
        <!-- =========================================================== -->
        <record id="hr_rule_provision_intereses_cesantias" model="hr.salary.rule">
            <field name="name">Provisión Intereses Cesantías (1% Mensual)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">251</field>
            <field name="code">PROV_INTCES</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
# is_apprentice_lectiva = False # No directamente usado en la condición de PROV_INTCES
# is_apprentice_productiva = False # No directamente usado
is_any_apprentice = False

if contract: 
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12' or worker_type_code_dian == '19': 
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# Para la condición de PROV_INTCES, necesitamos la misma base que para PROV_CES.
# valor_cesantias_provisionadas = categories.get('PROV_CES', 0.0) # Si PROV_INTCES se calcula sobre la PROV_CES del mes

# Usaremos la misma lógica que PROV_CES para obtener 'base_prestaciones_valor'.
# Si tu regla PROV_CES repite el cálculo:

base_prestaciones_valor_cond = categories.get('IBC_AUX', 0.0)

# --- Common helper variables ---
precision_rounding = 0.01 
try: 
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PROV_INTCES condition ---
# Aplica a empleados REGULARES que también tuvieron provisión de cesantías (o base para ello).
result = False
if is_regular and not (abs(base_prestaciones_valor_cond) < precision_rounding):
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PROV_INTCES amount ---
result = 0.0 
provision_intereses_calculada = 0.0 # Inicializar

# Obtener la base para la provisión de intereses.
# Esta es la misma base que usas para la provisión de cesantías,

base_para_provision_intereses = categories.get('IBC_AUX', 0.0)

# Solo calcular si la base es significativamente mayor que cero
if not (abs(base_para_provision_intereses) < precision_rounding):
    # Provisión mensual de intereses es el 1% de la base de prestaciones del mes
    provision_intereses_calculada = base_para_provision_intereses * 0.01

    # Lógica de Redondeo (aplicada a provision_intereses_calculada)
    num_decimals = 2 
    if currency_rounding == 0.01: num_decimals = 2
    elif currency_rounding == 1.0: num_decimals = 0 
    # No se necesitan redondeos a -1 o -2 para intereses usualmente.
    
    if num_decimals >= 0:
        factor = 10 ** num_decimals
        result = float(int(provision_intereses_calculada * factor + (0.5 if provision_intereses_calculada >=0 else -0.5))) / factor
    else: 
        # Si por alguna razón necesitas redondear a decenas/centenas (poco común para intereses)
        factor = 10 ** abs(num_decimals)
        result = float(int(provision_intereses_calculada / factor + (0.5 if provision_intereses_calculada >=0 else -0.5))) * factor
else:
    result = 0.0 
            ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <!-- Las provisiones no se detallan en el XML de Nómina Electrónica -->
            <!-- No tienen type_concept ni earn/deduction_category -->
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>

            <!-- Partner asociado para la provisión: Es el empleado -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
            ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLA: PROVISIÓN PRIMA SERVICIOS (PROV_PRI) - AJUSTADA -->
        <!-- =========================================================== -->
        <record id="hr_rule_provision_prima" model="hr.salary.rule">
            <field name="name">Provisión Prima Servicios (8.33%)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">252</field>
            <field name="code">PROV_PRI</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
is_regular = False
is_integral = False
is_any_apprentice = False # Provisión de prima no aplica a aprendices de esta forma

if contract: 
    try:
        if contract.integral_salary: 
            is_integral = True
    except AttributeError:
        pass 

    try:
        if contract.type_worker_id and contract.type_worker_id.code: 
            worker_type_code_dian = contract.type_worker_id.code
            if worker_type_code_dian == '12' or worker_type_code_dian == '19': 
                is_any_apprentice = True
    except AttributeError:
        pass 
            
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
# Usar tu NUEVA categoría donde está el resultado de "Base Prestaciones Sociales (Con Aux. Trans.)"
base_prima_calculada = categories.get('IBC_AUX', 0.0) # <-- USA TU NUEVA CATEGORÍA 'IBC_AUX'

# --- Common helper variables ---
precision_rounding = 0.01 
try: 
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PROV_PRI condition ---
# La provisión de prima aplica a empleados REGULARES.
# Los integrales podrían tenerla incluida o una regla diferente si se les paga directamente.
# La provisión se hace si la base de prima es mayor a cero.
result = False
if is_regular and not (abs(base_prima_calculada) < precision_rounding):
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3 - Aplicado)
# ======================================================
# --- Fetching key values from categories ---
# Usar tu NUEVA categoría donde está el resultado de "Base Prestaciones Sociales (Con Aux. Trans.)"
base_prima_calculada = categories.get('IBC_AUX', 0.0) # <-- USA TU NUEVA CATEGORÍA 'IBC_AUX'

# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
try:
    if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
        current_payslip_currency_rounding_val = payslip.currency_id.rounding
        temp_float_rounding = float(current_payslip_currency_rounding_val)
        if 0.0 <= temp_float_rounding <= 1.0 : 
            currency_rounding = temp_float_rounding
            precision_rounding = temp_float_rounding
except (AttributeError, ValueError, TypeError):
    pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for PROV_PRI amount ---
result = 0.0 
base_prov = base_prima_calculada # Usar el valor de la categoría 'IBC_AUX'

# Fórmula: Base Prestaciones (con Aux Trans) * (1/12) o 8.3333...%
if not (abs(base_prov) < precision_rounding): # Si la base es significativamente > 0
    # Usar 1.0/12.0 para asegurar división flotante y precisión
    provision_calculada = base_prov * (1.0 / 12.0) 

    # Lógica de Redondeo
    num_decimals = 2 
    if currency_rounding == 0.01: num_decimals = 2
    elif currency_rounding == 1.0: num_decimals = 0
    # No se suelen necesitar redondeos a decenas/centenas para provisiones individuales.
    
    if num_decimals >= 0:
        factor = 10 ** num_decimals
        result = float(int(provision_calculada * factor + (0.5 if provision_calculada >=0 else -0.5))) / factor
    else: 
        result = provision_calculada # Fallback si num_decimals es negativo
else:
    result = 0.0 
            ]]>
            </field>
            <!-- === Campos Específicos Nómina Electrónica Colombia === -->
            <!-- Las provisiones no se detallan en el XML de Nómina Electrónica -->
            <!-- No tienen type_concept ni earn/deduction_category -->
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>

            <!-- Partner asociado para la provisión: Es el empleado -->
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
            ]]>
            </field>
        </record>

       <!-- =========================================================== -->
        <!--      REGLA: PROVISIÓN VACACIONES (PROV_VAC) - AJUSTADA para Integral     -->
        <!-- =========================================================== -->
        <record id="hr_rule_provision_vacaciones" model="hr.salary.rule">
            <field name="name">Provisión Vacaciones (Regular y Integral)</field> <!-- Nombre actualizado -->
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">253</field>
            <field name="code">PROV_VAC</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <!-- Condición: Aplicar si hay contrato Y NO es aprendiz SENA -->
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0)
# apoyo_sost = categories.get('APOYO_SOST', 0.0)
# Access BASE_PRESTACIONES which should have a lower sequence (e.g., 102)
base_prestaciones = categories.get('BASE_PRESTACIONES', 0.0)

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for PROV_VAC condition ---
# Condición: Aplica a Empleados Regulares o Integrales (si hay contrato)
# is_regular e is_integral vienen del preámbulo.
if contract and (is_regular or is_integral):
    result = True
else:
    result = False
                ]]>
            </field>
            <field name="amount_select">code</field>
            <!-- Cálculo: Diferenciar entre Regular (base IBC) e Integral (base 70%/1.3) -->
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env

# --- Python Built-ins assumed available (MINIMAL SET) ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination ---
is_regular = False
is_integral = False
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False
if contract:
    if contract.integral_salary:
        is_integral = True
    if contract.contract_type_id and contract.contract_type_id.code:
        contract_type_code = contract.contract_type_id.code
        if contract_type_code == '4':
            is_apprentice_lectiva = True; is_any_apprentice = True
        elif contract_type_code == '5':
            is_apprentice_productiva = True; is_any_apprentice = True
    if not is_integral and not is_any_apprentice:
        is_regular = True

# --- Fetching key values from categories ---
ibc = categories.get('IBC', 0.0) # Usado para regular
# apoyo_sost = categories.get('APOYO_SOST', 0.0)
# base_prestaciones = categories.get('BASE_PRESTACIONES', 0.0) # No se usa directamente aquí, se usa IBC o salario integral

# --- Company specific values ---
smmlv = 0.0
uvt_value = 0.0
is_exonerated_company = False
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id

if company_obj:
    smmlv_from_company = company_obj.smmlv_value
    temp_smmlv = 0.0
    try: temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0

    uvt_from_company = company_obj.uvt_value
    temp_uvt = 0.0
    try: temp_uvt = float(uvt_from_company)
    except (ValueError, TypeError): pass
    if temp_uvt > 0: uvt_value = temp_uvt
    else: uvt_value = 0.0

    is_exonerated_company = bool(company_obj.ley_1607)

# --- Common helper variables ---
currency_rounding = 0.01
precision_rounding = 0.01
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if test_float >= 0 and test_float <= 1.0 :
             currency_rounding = test_float
             precision_rounding = test_float
    except (ValueError, TypeError):
        pass
# ======================================================
# Common Preamble for Salary Rules - END (Ultra-Restrictive Env v3)
# ======================================================

# --- Specific Rule Logic for PROV_VAC amount ---
result = 0.0 # Provisión mensual
base_vacaciones = 0.0 # Base a usar para la provisión mensual

# --- Calcular Base de Provisión según Tipo de Empleado ---
if is_regular:
    # Para Regular: Base es IBC (asumiendo que IBC es el salario básico mensual sin auxilio de transporte,
    # ya que el auxilio de transporte no es base para vacaciones).
    # Si IBC ya incluye el auxilio, se debe ajustar o usar una categoría diferente.
    # Por ahora, asumimos que IBC es la base correcta para vacaciones de un regular.
    base_vacaciones = ibc
    
elif is_integral:
    # Para Integral: Base es (Salario Integral Total / 1.3)
    # Acceso directo a contract.wage
    integral_salary_total = 0.0
    if contract:
        try:
            integral_salary_total = float(contract.wage)
        except (ValueError, TypeError, AttributeError): # Captura si wage no es numérico o no existe
            integral_salary_total = 0.0
            
    factor_prestacional_divisor = 1.3 # Base + 30% factor

    # Reemplazo de float_is_zero(integral_salary_total, precision_rounding=precision_rounding)
    condition_integral_salary_not_zero = not (abs(integral_salary_total) < precision_rounding)

    if condition_integral_salary_not_zero and factor_prestacional_divisor > 0:
         base_vacaciones = integral_salary_total / factor_prestacional_divisor
    # Si integral_salary_total es cero o divisor es cero, base_vacaciones permanece 0.0

# --- Calcular Provisión Mensual ---
# Fórmula: Base de Vacaciones * (15 días / 360 días) = Base de Vacaciones * (1/24)
# O Base de Vacaciones * 0.041666666666666664
aporte_vacaciones = 0.0
# Reemplazo de float_is_zero(base_vacaciones, precision_rounding=precision_rounding)
condition_base_vacaciones_not_zero = not (abs(base_vacaciones) < precision_rounding)

if condition_base_vacaciones_not_zero:
    aporte_vacaciones = base_vacaciones * 0.041666666666666664 # (1/24)

# Redondeo estándar para provisiones
# Reemplazo de float_is_zero(aporte_vacaciones, precision_rounding=precision_rounding)
condition_aporte_vacaciones_not_zero = not (abs(aporte_vacaciones) < precision_rounding)

if condition_aporte_vacaciones_not_zero:
    rounded_value = 0.0
    if payslip and payslip.currency_id:
        try:
            rounded_value = payslip.currency_id.round(aporte_vacaciones)
        except Exception:
            temp_rounded = int(aporte_vacaciones * 100 + 0.5)
            rounded_value = float(temp_rounded) / 100.0
    else:
        temp_rounded = int(aporte_vacaciones * 100 + 0.5)
        rounded_value = float(temp_rounded) / 100.0
    result = rounded_value
else:
    result = 0.0
            ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <field name="co_partner_select">code</field>
            <field name="co_partner_python_compute">
                <![CDATA[
# ======================================================
# Código para Computar Partner (NE) - Empleado vía Contrato
# ======================================================
result = None
try:
    if contract and contract.employee_id and contract.employee_id.address_id:
        result = contract.employee_id.address_id.id
except Exception:
    result = None
            ]]>
            </field>
        </record>

        <!-- =========================================================== -->
        <!--      REGLAS ESPECÍFICAS PARA APRENDICES (SOBRE 1 SMMLV)     -->
        <!-- =========================================================== -->
        <record id="hr_rule_aporte_salud_empleador_aprendiz" model="hr.salary.rule">
            <field name="name">Aporte Salud Empleador (Aprendiz)</field>
            <field name="struct_id" ref="l10n_co_nomina.hr_payroll_structure_co_base"/>
            <field name="sequence">205</field> <!-- Secuencia cercana a otros aportes salud -->
            <field name="code">SALUD_PAT_APR</field>
            <field name="category_id" ref="hr_payroll.COMP"/>
            <field name="condition_select">python</field>
            <field name="condition_python">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3)
# ======================================================
# --- Environment objects (Automatically available) ---
# payslip, employee, contract, categories, inputs, worked_days, rule, env
# --- Python Built-ins ---
# abs(), int(), float(), bool(), round()
# Basic operators: +, -, *, /, %, <, >, <=, >=, ==, !=, and, or, not, is
# Standard Exceptions like ValueError, TypeError are assumed to be namable.
# KEYWORDS/FUNCTIONS NOT AVAILABLE: AttributeError (keyword), hasattr, getattr, float_is_zero, type

# --- Employee Type Determination (Basado en Tipo de Trabajador DIAN desde el Contrato) ---
is_apprentice_lectiva = False
is_apprentice_productiva = False
is_any_apprentice = False # Conveniencia, aunque no se use directamente en esta condición específica

if contract:
    # Identificación de aprendiz basada en type_worker_id del contrato
    if contract.type_worker_id and contract.type_worker_id.code: 
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': # Código DIAN para Aprendiz SENA Etapa Lectiva
            is_apprentice_lectiva = True
            is_any_apprentice = True
        elif dian_worker_type_code == '19': # Código DIAN para Aprendiz SENA Etapa Productiva
            is_apprentice_productiva = True
            is_any_apprentice = True

# --- Company specific values ---
smmlv = 0.0
company_obj = None
if contract and contract.company_id: 
    company_obj = contract.company_id
if company_obj:
    smmlv_from_company = company_obj.smmlv_value # Acceso directo
    temp_smmlv = 0.0
    try: 
        temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0
# --- Common helper variables ---
# (precision_rounding no es usado en esta condición, pero se define en amount_compute)
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALUD_PAT_APR condition ---
result = False
# Aplica si es Aprendiz (lectiva o productiva), tiene EPS asignada y SMMLV es válido.
if contract and contract.eps_id and (is_apprentice_lectiva or is_apprentice_productiva) and smmlv > 0:
    result = True
                ]]>
            </field>
            <field name="amount_select">code</field>
            <field name="amount_python_compute">
                <![CDATA[
# ======================================================
# Common Preamble for Salary Rules - START (Ultra-Restrictive Env v3) - Reaplicado aquí
# ======================================================
# --- Environment objects (Automatically available) ---
# --- Python Built-ins --- (Como arriba)

# --- Employee Type Determination (Basado en Tipo de Trabajador DIAN desde el Contrato) ---
# (No es estrictamente necesario redefinir aquí si la condición ya filtró correctamente,
#  pero se mantiene por claridad si se necesitara diferenciar lectiva/productiva en el monto)
is_apprentice_lectiva = False
is_apprentice_productiva = False
if contract:
    if contract.type_worker_id and contract.type_worker_id.code: 
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': 
            is_apprentice_lectiva = True
        elif dian_worker_type_code == '19': 
            is_apprentice_productiva = True
# --- Company specific values ---
smmlv = 0.0
company_obj = None
if contract and contract.company_id:
    company_obj = contract.company_id
if company_obj:
    smmlv_from_company = company_obj.smmlv_value 
    temp_smmlv = 0.0
    try: 
        temp_smmlv = float(smmlv_from_company)
    except (ValueError, TypeError): pass
    if temp_smmlv > 0: smmlv = temp_smmlv
    else: smmlv = 0.0
# --- Common helper variables ---
currency_rounding = 0.01 
precision_rounding = 0.01 
if payslip and payslip.currency_id and payslip.currency_id.rounding is not None:
    current_payslip_currency_rounding = payslip.currency_id.rounding
    try:
        test_float = float(current_payslip_currency_rounding)
        if 0.0 <= test_float <= 1.0 : 
            currency_rounding = test_float
            precision_rounding = test_float
    except (ValueError, TypeError): pass
# ======================================================
# Common Preamble for Salary Rules - END
# ======================================================

# --- Specific Rule Logic for SALUD_PAT_APR amount ---
result = 0.0
result_qty = 1.0 # El aporte es un monto único

# La condición ya aseguró que es Aprendiz (lectiva o productiva) y SMMLV > 0.
base_cotizacion_salud_aprendiz = smmlv # Base para aprendices es 1 SMMLV

# El empleador asume el 12.5% completo para salud de aprendices (lectiva y productiva).
aporte_percentage_salud_total_empresa = 0.125 

if not (abs(base_cotizacion_salud_aprendiz) < precision_rounding) and aporte_percentage_salud_total_empresa > 0:
    aporte_calculado = base_cotizacion_salud_aprendiz * aporte_percentage_salud_total_empresa
    
    if payslip and payslip.currency_id:
        result = payslip.currency_id.round(aporte_calculado)
    else:
        # Aportes suelen redondearse al peso más cercano o según PILA.
        # Usaremos redondeo a 0 decimales como fallback general si no hay moneda.
        # Para PILA exacto (centena superior), se necesitaría lógica adicional si math.ceil no está.
        result = round(aporte_calculado, 0) 
else:
    result = 0.0

if abs(result) < precision_rounding: 
    result = 0.0
                ]]>
            </field>
            <field name="appears_on_payslip" eval="False"/>
            <field name="type_concept">other</field>
            <!-- earn_category es más para nómina electrónica, verificar código DIAN -->
            <!-- <field name="earn_category">health_contribution</field> -->

            <field name="edi_is_detailed" eval="False"/>
            <field name="edi_quantity_select">default</field>
            <field name="edi_percent_select">code</field>
            <field name="edi_percent_python_compute">
                <![CDATA[
# Preamble para obtener is_apprentice_lectiva, is_apprentice_productiva
is_apprentice_lectiva = False
is_apprentice_productiva = False
if contract: # Asumimos que 'contract' está disponible
    if contract.type_worker_id and contract.type_worker_id.code:
        dian_worker_type_code = contract.type_worker_id.code
        if dian_worker_type_code == '12': is_apprentice_lectiva = True
        elif dian_worker_type_code == '19': is_apprentice_productiva = True
# ======================================================
result = 0.0
# Para Nómina Electrónica, se reporta el porcentaje del APORTE TOTAL A SALUD para el aprendiz.
# La empresa paga el 12.5% completo.
if is_apprentice_lectiva or is_apprentice_productiva:
    result = 12.5 # Porcentaje total a cargo de la empresa
                ]]>
            </field>
            <field name="co_partner_select">default</field>
            <field name="co_partner_python_compute">
                <![CDATA[
result = None
if contract and contract.eps_id and contract.eps_id.partner_id: # Acceso directo
    result = contract.eps_id.partner_id.id     
                ]]>
            </field>
        </record>
    </data>
</odoo>